<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>NEON DEFENSE: ARCADE EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Orbitron', sans-serif; user-select: none; }
        
        /* UI OVERLAY */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* HUD STYLES */
        .hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        
        .stat-box {
            text-align: center; color: #fff; text-shadow: 0 0 10px currentColor;
            background: rgba(0, 10, 20, 0.6); border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 20px; border-radius: 4px; transform: skewX(-10deg);
        }
        .stat-label { font-size: 10px; color: #aaa; letter-spacing: 2px; }
        .stat-value { font-size: 28px; font-weight: 900; }

        #money-display { color: #f0e; border-color: #f0e; }
        #lives-display { color: #0ff; border-color: #0ff; }
        #wave-display { color: #ff0; border-color: #ff0; }

        /* GAME CONTROLS */
        .game-controls {
            position: absolute; top: 120px; right: 20px;
            display: flex; flex-direction: column; gap: 10px; pointer-events: auto;
        }
        
        .control-btn {
            padding: 10px 20px; background: rgba(0,0,0,0.8); border: 2px solid #0ff;
            color: #0ff; font-family: 'Orbitron'; font-weight: bold; cursor: pointer;
            transition: 0.2s; font-size: 14px;
        }
        .control-btn:hover { background: #0ff; color: #000; box-shadow: 0 0 20px #0ff; }
        .control-btn.pause { border-color: #ff0; color: #ff0; }
        .control-btn.pause:hover { background: #ff0; }

        /* LIGHT CONTROLS */
        .light-panel {
            position: absolute; top: 80px; left: 20px; pointer-events: auto;
            background: rgba(0,0,0,0.9); padding: 15px; border-radius: 10px;
            border: 1px solid #0ff; min-width: 200px; max-height: 80vh; overflow-y: auto;
        }
        .light-panel h4 { color: #0ff; margin: 0 0 10px 0; font-size: 14px; }
        .light-slider { width: 100%; margin: 5px 0; }
        
        .toggle-btn {
            width: 100%; padding: 8px; margin: 5px 0;
            background: #222; border: 2px solid #555; color: #fff;
            font-family: 'Orbitron'; font-weight: bold; cursor: pointer;
            transition: 0.2s; font-size: 12px;
        }
        .toggle-btn.active { background: #0f0; color: #000; border-color: #0f0; }
        .toggle-btn:hover { border-color: #0ff; }

        /* BUILD MENU */
        #build-menu {
            pointer-events: auto;
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px;
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 10px; border: 1px solid #333;
        }
        
        .tower-btn {
            width: 80px; height: 80px;
            background: #111; border: 2px solid #333; color: #fff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s; font-family: 'Orbitron'; position: relative;
        }
        .tower-btn:hover { transform: scale(1.1); border-color: #fff; box-shadow: 0 0 15px #fff; }
        .tower-btn.selected { border-color: #0f0; background: #002200; box-shadow: 0 0 10px #0f0; }
        .tower-btn.disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }
        .tower-price { font-size: 12px; color: #ff0; margin-top: 5px; }
        .tower-name { font-size: 10px; font-weight: bold; }
        
        .delete-mode { border-color: #f00 !important; background: #220000 !important; }
        .delete-mode:hover { box-shadow: 0 0 10px #f00 !important; }

        /* TOWER INFO PANEL */
        .tower-info-panel {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); padding: 15px; border-radius: 10px;
            border: 2px solid #0ff; pointer-events: auto; min-width: 300px;
            display: none;
        }
        .tower-info-panel h3 { color: #0ff; margin: 0 0 10px 0; }
        .tower-stat { color: #fff; margin: 5px 0; font-size: 14px; }
        .upgrade-btn {
            width: 100%; padding: 10px; margin-top: 10px;
            background: #0f0; color: #000; border: none;
            font-family: 'Orbitron'; font-weight: bold; cursor: pointer;
            transition: 0.2s;
        }
        .upgrade-btn:hover { box-shadow: 0 0 20px #0f0; transform: scale(1.05); }
        .upgrade-btn:disabled { background: #333; color: #666; cursor: not-allowed; }
        .sell-btn {
            width: 100%; padding: 10px; margin-top: 5px;
            background: #f00; color: #fff; border: none;
            font-family: 'Orbitron'; font-weight: bold; cursor: pointer;
        }
        .sell-btn:hover { box-shadow: 0 0 20px #f00; }

        /* MENUS */
        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; backdrop-filter: blur(5px); z-index: 10;
            overflow-y: auto;
        }
        
        h1 { 
            font-size: 60px; margin: 0; 
            background: linear-gradient(to right, #0ff, #f0e); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; 
            text-shadow: 0 0 30px rgba(0,255,255,0.5); 
        }
        h2 { color: #fff; margin-bottom: 30px; }
        h3 { color: #0ff; margin: 15px 0 5px 0; }
        
        .btn-main {
            padding: 15px 40px; font-size: 24px; font-family: 'Orbitron'; font-weight: bold;
            background: transparent; color: #0ff; border: 2px solid #0ff;
            cursor: pointer; text-transform: uppercase; margin: 10px;
            transition: 0.2s; position: relative; overflow: hidden;
        }
        .btn-main:hover { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
        
        .btn-small {
            padding: 8px 20px; font-size: 14px; font-family: 'Orbitron'; font-weight: bold;
            background: transparent; color: #f0e; border: 2px solid #f0e;
            cursor: pointer; text-transform: uppercase; margin: 5px;
            transition: 0.2s;
        }
        .btn-small:hover { background: #f0e; color: #000; box-shadow: 0 0 20px #f0e; }
        
        .level-select-container { display: flex; gap: 20px; margin-top: 20px; flex-wrap: wrap; justify-content: center; }
        .level-card {
            width: 150px; height: 100px; border: 1px solid #555; background: #111;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            color: #888; transition: 0.3s; text-align: center; padding: 10px;
        }
        .level-card:hover { border-color: #f0e; color: #f0e; transform: translateY(-5px); }
        .level-card.locked { opacity: 0.3; pointer-events: none; }
        .level-card.sandbox { border-color: #0f0; color: #0f0; }
        .level-card.sandbox:hover { box-shadow: 0 0 20px #0f0; }

        /* HIGHSCORE */
        .highscore-panel {
            background: rgba(20,20,20,0.9); padding: 20px; border-radius: 10px;
            border: 1px solid #ff0; margin-top: 20px; max-width: 400px;
        }
        .highscore-entry {
            display: flex; justify-content: space-between; padding: 5px 0;
            color: #fff; border-bottom: 1px solid #333;
        }
        .highscore-entry:first-child { color: #ff0; font-weight: bold; }

        #msg-area {
            position: absolute; top: 20%; width: 100%; text-align: center;
            font-size: 40px; font-weight: bold; color: #fff; pointer-events: none;
            text-shadow: 0 0 20px #fff; opacity: 0; transition: opacity 0.5s;
        }

        /* PAUSE SCREEN */
        .pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(10px);
            display: none; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 15;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-box" id="lives-display">
                <div class="stat-label">NEURO-CORE INTEGRITY</div>
                <div class="stat-value" id="lives-val">100%</div>
            </div>
            <div class="stat-box" id="wave-display">
                <div class="stat-label">WAVE</div>
                <div class="stat-value" id="wave-val">1</div>
            </div>
            <div class="stat-box" id="money-display">
                <div class="stat-label">CREDITS</div>
                <div class="stat-value" id="money-val">0</div>
            </div>
        </div>

        <!-- GAME CONTROLS -->
        <div class="game-controls" style="display:none;" id="game-controls">
            <button class="control-btn pause" onclick="togglePause()">‚è∏Ô∏è PAUSE</button>
            <button class="control-btn" onclick="showMenu()">üìã MENU</button>
        </div>

        <!-- LIGHT PANEL -->
        <div class="light-panel" style="display:none;" id="light-panel">
            <h4>‚öôÔ∏è SETTINGS</h4>
            
            <button class="toggle-btn active" id="sound-toggle" onclick="toggleSound()">üîä SOUND: ON</button>
            
            <label style="color:#fff; font-size:12px; margin-top:10px; display:block;">üí° Ambient: <span id="ambient-val">0.4</span></label>
            <input type="range" class="light-slider" min="0" max="100" value="40" oninput="updateLighting('ambient', this.value)">
            
            <label style="color:#fff; font-size:12px; margin-top:10px; display:block;">‚òÄÔ∏è Directional: <span id="dir-val">1.2</span></label>
            <input type="range" class="light-slider" min="0" max="200" value="120" oninput="updateLighting('directional', this.value)">
            
            <label style="color:#fff; font-size:12px; margin-top:10px; display:block;">üé® Color Hue: <span id="hue-val">180¬∞</span></label>
            <input type="range" class="light-slider" min="0" max="360" value="180" oninput="updateLighting('hue', this.value)">
            
            <label style="color:#fff; font-size:12px; margin-top:10px; display:block;">‚ö° Game Speed: <span id="speed-val">1.0x</span></label>
            <input type="range" class="light-slider" min="10" max="200" value="100" oninput="updateGameSpeed(this.value)">
        </div>

        <div id="msg-area">WAVE COMPLETE</div>

        <!-- BUILD MENU -->
        <div id="build-menu" style="display:none;">
            <div class="tower-btn selected" data-type="0" onclick="selectTower(0)">
                <div class="tower-name">HACKER-0</div>
                <div style="font-size:20px;">üë®‚Äçüíª</div>
                <div class="tower-price">50 CR</div>
            </div>
            <div class="tower-btn" data-type="1" onclick="selectTower(1)">
                <div class="tower-name">HACKER-1</div>
                <div style="font-size:20px;">üéØ</div>
                <div class="tower-price">120 CR</div>
            </div>
            <div class="tower-btn" data-type="2" onclick="selectTower(2)">
                <div class="tower-name">HACKER-X</div>
                <div style="font-size:20px;">üíª</div>
                <div class="tower-price">200 CR</div>
            </div>
            <div class="tower-btn" onclick="toggleDeleteMode()">
                <div class="tower-name">DELETE</div>
                <div style="font-size:20px;">üóëÔ∏è</div>
                <div class="tower-price">SELL</div>
            </div>
        </div>

        <!-- TOWER INFO -->
        <div class="tower-info-panel" id="tower-info-panel">
            <h3 id="tower-info-name">Hacker</h3>
            <div class="tower-stat" id="tower-info-level">Level: 1</div>
            <div class="tower-stat" id="tower-info-damage">Damage: 10</div>
            <div class="tower-stat" id="tower-info-range">Range: 15</div>
            <div class="tower-stat" id="tower-info-rate">Fire Rate: 0.6s</div>
            <button class="upgrade-btn" id="upgrade-btn" onclick="upgradeTower()">UPGRADE (100 CR)</button>
            <button class="sell-btn" onclick="sellTower()">SELL (25 CR)</button>
        </div>
    </div>

    <!-- PAUSE OVERLAY -->
    <div class="pause-overlay" id="pause-overlay">
        <div style="text-align: center;">
            <h1 style="-webkit-text-fill-color: #ff0;">‚è∏Ô∏è PAUSED</h1>
            <button class="btn-main" onclick="togglePause()">RESUME</button>
            <button class="btn-main" onclick="restartLevel()">RESTART</button>
            <button class="btn-main" onclick="showMenu()">MAIN MENU</button>
        </div>
    </div>

    <!-- START SCREEN -->
    <div id="start-screen" class="overlay-screen">
        <h1>NEON DEFENSE</h1>
        <h2>PROTECT THE NEURO-CORE</h2>
        <div class="level-select-container">
            <div class="level-card" onclick="startGame(0)">LEVEL 1<br>The Snake</div>
            <div class="level-card" onclick="startGame(1)">LEVEL 2<br>The Spiral</div>
            <div class="level-card" onclick="startGame(2)">LEVEL 3<br>ZigZag</div>
            <div class="level-card" onclick="startGame(3)">LEVEL 4<br>Balloons üéà</div>
            <div class="level-card sandbox" onclick="openSandbox()">SANDBOX<br>MODE üõ†Ô∏è</div>
        </div>

        <div class="highscore-panel">
            <h3 style="text-align:center;">üèÜ HIGH SCORES</h3>
            <div id="highscore-list"></div>
        </div>
    </div>

    <!-- SANDBOX SETUP -->
    <div id="sandbox-setup-screen" class="overlay-screen" style="display:none;">
        <h1 style="-webkit-text-fill-color: #0f0;">SANDBOX MODE</h1>
        <div style="text-align:center; padding:20px;">
            <p style="color:#888;">Sandbox setup interface...</p>
            <button class="btn-main" onclick="closeSandbox()">BACK</button>
        </div>
    </div>

    <!-- GAME OVER -->
    <div id="game-over-screen" class="overlay-screen" style="display:none;">
        <h1 style="color:red; -webkit-text-fill-color: red;">AI TAKEOVER COMPLETE</h1>
        <h2 id="final-score">The Neuro-Core has been compromised</h2>
        <button class="btn-main" onclick="restartLevel()">RESTART</button>
        <button class="btn-main" onclick="showMenu()">MAIN MENU</button>
    </div>

    <!-- VICTORY -->
    <div id="victory-screen" class="overlay-screen" style="display:none;">
        <h1 style="color:#0f0; -webkit-text-fill-color: #0f0;">CORE SECURED</h1>
        <h2 id="victory-msg">Next Level Unlocked</h2>
        <button class="btn-main" onclick="restartLevel()">RESTART</button>
        <button class="btn-main" onclick="showMenu()">MAIN MENU</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SONIC WAVE AUDIO ENGINE ---
        class SfxEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.initialized = false;
                this.enabled = true;
                this.masterVolume = 0.3;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = this.masterVolume;
                    this.masterGain.connect(this.ctx.destination);
                    this.initialized = true;
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                } catch(e) {
                    console.log('Audio init failed:', e);
                }
            }

            // HACKER-0: Sonic Wave
            playSonicWave() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.5);
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(8, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(20, now);
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    osc.connect(gainNode);
                    
                    gainNode.gain.setValueAtTime(0.25, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.5);
                    lfo.stop(now + 0.5);
                } catch(e) {}
            }

            // HACKER-1: Tremolo Wave
            playTremoloWave() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, now);
                    osc.connect(gainNode);
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(15, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(0.15, now);
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(gainNode.gain);
                    
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.6);
                    lfo.stop(now + 0.6);
                } catch(e) {}
            }

            // HACKER-2: Underwater Echo
            playUnderwaterEcho() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(120, now);
                    osc.frequency.linearRampToValueAtTime(90, now + 0.6);
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(800, now);
                    filter.Q.setValueAtTime(5, now);
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(4, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(200, now);
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                    osc.connect(filter);
                    filter.connect(gainNode);
                    
                    gainNode.gain.setValueAtTime(0.25, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.6);
                    lfo.stop(now + 0.6);
                } catch(e) {}
            }

            // BUILD: Deep Pulse
            playBuild() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(60, now);
                    osc.frequency.linearRampToValueAtTime(30, now + 0.4);
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(3, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(15, now);
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    osc.connect(gainNode);
                    
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.4);
                    lfo.stop(now + 0.4);
                } catch(e) {}
            }

            // UPGRADE: Rising Swell
            playUpgrade() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.exponentialRampToValueAtTime(300, now + 0.7);
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(6, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(25, now);
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    osc.connect(gainNode);
                    
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.linearRampToValueAtTime(0.3, now + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.7);
                    
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.7);
                    lfo.stop(now + 0.7);
                } catch(e) {}
            }

            // ERROR: Wobble Bass
            playError() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(80, now);
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, now);
                    filter.Q.setValueAtTime(10, now);
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(6, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(800, now);
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                    osc.connect(filter);
                    filter.connect(gainNode);
                    
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.4);
                    lfo.stop(now + 0.4);
                } catch(e) {}
            }

            // ENEMY DEATH: Resonant Ring (short version for enemies)
            playResonantRing() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(200, now + 0.5);
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(400, now);
                    filter.Q.setValueAtTime(20, now);
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(7, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(100, now);
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                    osc.connect(filter);
                    filter.connect(gainNode);
                    
                    gainNode.gain.setValueAtTime(0.25, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.5);
                    lfo.stop(now + 0.5);
                } catch(e) {}
            }

            // CORE HIT: Phase Shift
            playCoreHit() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const osc1 = this.ctx.createOscillator();
                    const osc2 = this.ctx.createOscillator();
                    osc1.type = 'sine';
                    osc2.type = 'sine';
                    osc1.frequency.setValueAtTime(150, now);
                    osc2.frequency.setValueAtTime(150.5, now);
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(0.5, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(5, now);
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc2.frequency);
                    
                    osc1.connect(gainNode);
                    osc2.connect(gainNode);
                    
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    
                    osc1.start(now);
                    osc2.start(now);
                    lfo.start(now);
                    osc1.stop(now + 0.6);
                    osc2.stop(now + 0.6);
                    lfo.stop(now + 0.6);
                } catch(e) {}
            }

            // CORE DESTROY: Resonant Ring (long version)
            playCoreDestroy() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 1.5);
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(400, now);
                    filter.Q.setValueAtTime(20, now);
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(7, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(100, now);
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                    osc.connect(filter);
                    filter.connect(gainNode);
                    
                    gainNode.gain.setValueAtTime(0.4, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
                    
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 1.5);
                    lfo.stop(now + 1.5);
                } catch(e) {}
            }

            // PHASE: Phase Shift (shorter version)
            playPhase() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const osc1 = this.ctx.createOscillator();
                    const osc2 = this.ctx.createOscillator();
                    osc1.type = 'sine';
                    osc2.type = 'sine';
                    osc1.frequency.setValueAtTime(200, now);
                    osc2.frequency.setValueAtTime(200.8, now);
                    
                    osc1.connect(gainNode);
                    osc2.connect(gainNode);
                    
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    
                    osc1.start(now);
                    osc2.start(now);
                    osc1.stop(now + 0.3);
                    osc2.stop(now + 0.3);
                } catch(e) {}
            }

            // HEAL: Harmonic Pulse (variation)
            playHeal() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    
                    const fundamentalFreq = 200;
                    const harmonics = [1, 1.5, 2];
                    
                    harmonics.forEach((harmonic, i) => {
                        const osc = this.ctx.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(fundamentalFreq * harmonic, now);
                        
                        const oscGain = this.ctx.createGain();
                        oscGain.gain.setValueAtTime(0.3 / harmonic, now);
                        
                        osc.connect(oscGain);
                        oscGain.connect(gainNode);
                        
                        osc.start(now);
                        osc.stop(now + 0.5);
                    });
                    
                    gainNode.gain.setValueAtTime(0.25, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                } catch(e) {}
            }
        }
        
        const sfx = new SfxEngine();

        // Sound toggle function
        window.toggleSound = function() {
            sfx.enabled = !sfx.enabled;
            const btn = document.getElementById('sound-toggle');
            if (sfx.enabled) {
                btn.classList.add('active');
                btn.innerText = 'üîä SOUND: ON';
            } else {
                btn.classList.remove('active');
                btn.innerText = 'üîá SOUND: OFF';
            }
        }

        // --- BACKGROUND MUSIC ---
        let bgMusic = null;
        function loadBackgroundMusic() {
            if (!sfx.enabled) return;
            try {
                bgMusic = new Audio('tower.mp3');
                bgMusic.loop = true;
                bgMusic.volume = 0.3;
                bgMusic.play().catch(e => {
                    console.log('Background music not found or failed to load:', e);
                    bgMusic = null;
                });
            } catch(e) {
                console.log('Could not load tower.mp3');
            }
        }

        // --- TEXTURE GENERATOR FOR BITS ---
        function createCharTexture(char, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 48px Courier New';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(char, 32, 32);
            const tex = new THREE.CanvasTexture(canvas);
            tex.needsUpdate = true;
            return tex;
        }

        let texZero, texOne, texHex;

        // --- CONFIG & STATE ---
        const TILE_SIZE = 4;
        let scene, camera, renderer, controls, raycaster, mouse;
        let pathBuilder = null;
        let ambientLight, directionalLight;
        let isPaused = false;
        let deleteMode = false;
        let selectedTower = null;
        let neuroCore = null;
        let portalGateway = null;
        let gameSpeed = 1.0;
        
        let gameState = {
            money: 400,
            lives: 20,
            wave: 1,
            levelIndex: 0,
            selectedTowerType: 0,
            isGameOver: false,
            sandboxConfig: {
                customPath: [],
                enemyCount: 5,
                enemyMix: { normal: 0.7, speed: 0.2, tank: 0.1 },
                difficultyScale: 1.0,
                bossInterval: 5,
                startingMoney: 450,
                color: new THREE.Color(0.0, 1.0, 0.5),
                towerRestrictions: [true, true, true],
                maxWaves: null
            }
        };

        // Tower Types - GAMEPLAY BLEIBT GLEICH
        const TOWER_TYPES = [
            { 
                name: "HACKER-0", 
                baseCost: 50, 
                upgrades: [
                    { damage: 10, range: 15, rate: 0.6, color: 0x00ffff, cost: 0 },
                    { damage: 20, range: 18, rate: 0.5, color: 0x00ddff, cost: 80 },
                    { damage: 35, range: 20, rate: 0.4, color: 0x0088ff, cost: 150 }
                ],
                projectileSpeed: 40
            },
            { 
                name: "HACKER-1", 
                baseCost: 120,
                upgrades: [
                    { damage: 50, range: 30, rate: 2.0, color: 0xffff00, cost: 0 },
                    { damage: 100, range: 40, rate: 1.5, color: 0xffcc00, cost: 200 },
                    { damage: 200, range: 50, rate: 1.2, color: 0xff8800, cost: 350 }
                ],
                projectileSpeed: 80
            },
            { 
                name: "HACKER-X", 
                baseCost: 200,
                upgrades: [
                    { damage: 20, range: 12, rate: 1.5, color: 0xff00ff, cost: 0, aoe: 8 },
                    { damage: 40, range: 15, rate: 1.2, color: 0xff00cc, cost: 250 },
                    { damage: 70, range: 18, rate: 1.0, color: 0xff0088, cost: 400, aoe: 12 }
                ],
                projectileSpeed: 25
            }
        ];

        // Levels
        const LEVELS = [
            {
                color: new THREE.Color(0.0, 1.0, 1.0),
                path: [{x:-8,z:-8}, {x:-8,z:-2}, {x:0,z:-2}, {x:0,z:2}, {x:8,z:2}, {x:8,z:8}]
            },
            {
                color: new THREE.Color(1.0, 0.0, 1.0),
                path: [{x:-10,z:-10}, {x:10,z:-10}, {x:10,z:10}, {x:-5,z:10}, {x:-5,z:-5}, {x:5,z:-5}, {x:5,z:5}, {x:0,z:5}]
            },
            {
                color: new THREE.Color(1.0, 1.0, 0.0),
                path: [{x:-8,z:8}, {x:-4,z:8}, {x:-4,z:-8}, {x:0,z:-8}, {x:0,z:8}, {x:4,z:8}, {x:4,z:-8}, {x:8,z:-8}, {x:8,z:8}]
            },
            {
                color: new THREE.Color(1.0, 0.5, 0.0),
                path: [{x:-10,z:-8}, {x:-2,z:-8}, {x:-2,z:0}, {x:8,z:0}, {x:8,z:8}],
                isBalloonLevel: true
            },
            {
                isSandbox: true,
                color: new THREE.Color(0.0, 1.0, 0.5),
                path: []
            }
        ];

        // Entities
        const entities = {
            towers: [],
            enemies: [],
            projectiles: [],
            particles: [],
            tiles: []
        };

        const shake = { amount: 0 };

        // --- SHADER BACKGROUND ---
        const bgUniforms = {
            uTime: { value: 0 },
            uColor: { value: new THREE.Vector3(0,1,1) }
        };
        const bgMaterial = new THREE.ShaderMaterial({
            uniforms: bgUniforms,
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec2 vUv;
                
                void main() {
                    vec2 grid = abs(fract(vUv * 20.0 - vec2(0, uTime * 0.2)) - 0.5) / fwidth(vUv * 20.0);
                    float line = min(grid.x, grid.y);
                    float alpha = 1.0 - min(line, 1.0);
                    
                    float dist = distance(vUv, vec2(0.5, 0.5));
                    alpha *= (1.0 - dist * 1.5);
                    
                    vec3 finalColor = uColor * alpha * 2.0;
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        // --- PORTAL GATEWAY CLASS ---
        class PortalGateway {
            constructor(x, z) {
                this.group = new THREE.Group();

                const ringGeo = new THREE.TorusGeometry(3, 0.4, 20, 50);
                const ringMat = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.4,
                    metalness: 0.9,
                    emissive: 0x001133,
                    emissiveIntensity: 0.3
                });
                this.ringMesh = new THREE.Mesh(ringGeo, ringMat);
                this.ringMesh.rotation.x = Math.PI / 2;
                this.group.add(this.ringMesh);

                const outerGlowGeo = new THREE.TorusGeometry(3.5, 0.08, 12, 50);
                const outerGlowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                this.outerGlow = new THREE.Mesh(outerGlowGeo, outerGlowMat);
                this.outerGlow.rotation.x = Math.PI / 2;
                this.group.add(this.outerGlow);

                const horizonVertShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;

                const horizonFragShader = `
                    uniform float uTime;
                    varying vec2 vUv;

                    void main() {
                        vec2 centeredUv = vUv - 0.5;
                        float dist = length(centeredUv);

                        float wave1 = sin(dist * 20.0 - uTime * 3.0);
                        float wave2 = sin(dist * 35.0 - uTime * 5.0 + 1.0);
                        float combinedWave = (wave1 + wave2) * 0.5;

                        vec3 colorDeep = vec3(0.0, 0.1, 0.4);
                        vec3 colorBright = vec3(0.0, 1.0, 0.8);
                        vec3 colorHot = vec3(0.6, 0.0, 1.0);

                        vec3 finalColor = mix(colorDeep, colorBright, combinedWave + 0.5);
                        finalColor += mix(colorHot, vec3(0.0), dist * 2.5);

                        float edgeMask = 1.0 - smoothstep(0.38, 0.48, dist);

                        gl_FragColor = vec4(finalColor, edgeMask * 0.9);
                    }
                `;

                this.horizonUniforms = { uTime: { value: 0 } };
                const horizonGeo = new THREE.CircleGeometry(3.2, 64);
                const horizonMat = new THREE.ShaderMaterial({
                    uniforms: this.horizonUniforms,
                    vertexShader: horizonVertShader,
                    fragmentShader: horizonFragShader,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                this.eventHorizon = new THREE.Mesh(horizonGeo, horizonMat);
                this.eventHorizon.rotation.x = Math.PI / 2;
                this.eventHorizon.position.y = 0.1;
                this.group.add(this.eventHorizon);

                const lightningGeo = new THREE.BufferGeometry();
                const lightningCount = 80;
                const lPos = new Float32Array(lightningCount * 3);
                lightningGeo.setAttribute('position', new THREE.BufferAttribute(lPos, 3));
                const lightningMat = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    opacity: 0.8,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                this.lightning = new THREE.LineSegments(lightningGeo, lightningMat);
                this.group.add(this.lightning);

                this.light = new THREE.PointLight(0x00ffff, 2, 20);
                this.light.position.set(0, 2, 0);
                this.group.add(this.light);

                this.group.position.set(x * TILE_SIZE, 1.5, z * TILE_SIZE);
                this.animTime = 0;

                scene.add(this.group);
            }

            update(dt) {
                this.animTime += dt;
                this.horizonUniforms.uTime.value = this.animTime;

                this.outerGlow.rotation.z = this.animTime * 0.5;
                
                const positions = this.lightning.geometry.attributes.position.array;
                for (let i = 0; i < 80; i += 2) {
                    const radiusBase = 3.3;
                    const angle1 = Math.random() * Math.PI * 2;
                    const angle2 = angle1 + (Math.random() - 0.5) * 0.5;

                    positions[i * 3] = Math.cos(angle1) * radiusBase + (Math.random() - 0.5);
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 2] = Math.sin(angle1) * radiusBase + (Math.random() - 0.5);

                    positions[i * 3 + 3] = Math.cos(angle2) * radiusBase + (Math.random() - 0.5);
                    positions[i * 3 + 4] = (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 5] = Math.sin(angle2) * radiusBase + (Math.random() - 0.5);
                }
                this.lightning.geometry.attributes.position.needsUpdate = true;
                this.lightning.material.opacity = 0.3 + Math.random() * 0.7;

                this.group.position.y = 1.5 + Math.sin(this.animTime * 0.5) * 0.2;
            }
        }

        // --- NEURO-CORE CLASS ---
        class NeuroCore {
            constructor(x, z) {
                this.group = new THREE.Group();
                this.health = 20;
                this.maxHealth = 20;
                this.destroyed = false;
                
                const coreGeo = new THREE.IcosahedronGeometry(2, 1);
                const coreMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                this.coreMesh = new THREE.Mesh(coreGeo, coreMat);
                this.group.add(this.coreMesh);

                const innerCoreMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6
                });
                this.innerCore = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 0), innerCoreMat);
                this.group.add(this.innerCore);

                this.blocks = [];
                const blockGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const blockMat = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.3,
                    metalness: 0.9,
                    roughness: 0.1
                });

                for(let i = 0; i < 12; i++) {
                    const block = new THREE.Mesh(blockGeo, blockMat.clone());
                    const radius = 3 + Math.random() * 1;
                    const theta = (i / 12) * Math.PI * 2;
                    const phi = Math.PI / 4 + (Math.random() - 0.5) * 0.5;
                    
                    block.position.setFromSphericalCoords(radius, phi, theta);
                    block.lookAt(0, 0, 0);
                    block.scale.set(1, 2 + Math.random() * 2, 1);
                    
                    this.group.add(block);
                    this.blocks.push({
                        mesh: block,
                        originalPos: block.position.clone(),
                        offset: i * 0.5
                    });
                }

                this.cables = [];
                for(let i = 0; i < 6; i++) {
                    const cableGeo = new THREE.CylinderGeometry(0.1, 0.1, 3, 6);
                    const cableMat = new THREE.MeshBasicMaterial({ 
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.6
                    });
                    const cable = new THREE.Mesh(cableGeo, cableMat);
                    const angle = (i / 6) * Math.PI * 2;
                    cable.position.set(Math.cos(angle) * 2, -2, Math.sin(angle) * 2);
                    cable.rotation.x = Math.PI / 6;
                    this.group.add(cable);
                    this.cables.push(cable);
                }

                this.light = new THREE.PointLight(0x00ffff, 2, 15);
                this.light.position.set(0, 2, 0);
                this.group.add(this.light);

                this.group.position.set(x * TILE_SIZE, 2, z * TILE_SIZE);
                this.animTime = 0;
                this.flashTime = 0;
                
                scene.add(this.group);
            }

            takeDamage() {
                if (this.destroyed) return;
                
                this.health--;
                this.flashTime = 0.3;
                sfx.playCoreHit();
                shake.amount = 0.8;

                const healthPct = this.health / this.maxHealth;
                const color = new THREE.Color().setHSL(healthPct * 0.5, 1, 0.5);
                
                this.coreMesh.material.color = color;
                this.light.color = color;
                this.blocks.forEach(b => {
                    b.mesh.material.emissive = color;
                });

                if (this.health <= 0) {
                    this.destroy();
                }
            }

            destroy() {
                this.destroyed = true;
                sfx.playCoreDestroy();
                shake.amount = 2;

                const growAnim = () => {
                    if (this.group.scale.x < 3) {
                        this.group.scale.multiplyScalar(1.02);
                        requestAnimationFrame(growAnim);
                    } else {
                        endGame();
                    }
                };
                growAnim();

                this.coreMesh.material.color.setHex(0xff0000);
                this.innerCore.material.color.setHex(0xff0000);
                this.light.color.setHex(0xff0000);
                this.light.intensity = 5;
                this.blocks.forEach(b => {
                    b.mesh.material.emissive.setHex(0xff0000);
                    b.mesh.material.emissiveIntensity = 1;
                });
            }

            update(dt) {
                if (this.destroyed) {
                    this.group.rotation.y += dt * 2;
                    return;
                }

                this.animTime += dt;

                const pulse = 1 + Math.sin(this.animTime * 3) * 0.1;
                this.coreMesh.scale.setScalar(pulse);
                this.innerCore.scale.setScalar(pulse * 0.8);
                
                this.coreMesh.rotation.y += dt * 0.5;
                this.coreMesh.rotation.z += dt * 0.3;
                this.innerCore.rotation.y -= dt * 0.7;

                this.blocks.forEach(block => {
                    block.mesh.position.y = block.originalPos.y + Math.sin(this.animTime * 2 + block.offset) * 0.3;
                    block.mesh.rotation.y += dt * 0.5;
                });

                if (this.flashTime > 0) {
                    this.flashTime -= dt;
                    const flash = Math.sin(this.flashTime * 30) * 0.5 + 0.5;
                    this.coreMesh.material.opacity = 0.5 + flash * 0.5;
                    this.innerCore.material.opacity = 0.3 + flash * 0.7;
                    this.light.intensity = 2 + flash * 3;
                } else {
                    this.coreMesh.material.opacity = 0.8;
                    this.innerCore.material.opacity = 0.6;
                    this.light.intensity = 2;
                }
            }
        }

        // --- CHARACTER BUILDER FUNCTION ---
        function createCharacter(type, scale, color, eyeColor) {
            const charGroup = new THREE.Group();
            
            const armorMat = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.9, 
                roughness: 0.1,
                emissive: color,
                emissiveIntensity: 0.3
            });

            let torsoScale = 1;
            let limbScale = 1;
            let headScale = 1;
            
            if (type === 'SPEED') {
                torsoScale = 0.7;
                limbScale = 1.3;
                headScale = 0.8;
            } else if (type === 'TANK') {
                torsoScale = 1.5;
                limbScale = 0.8;
                headScale = 1.2;
            } else if (type === 'BOSS') {
                torsoScale = 2;
                limbScale = 1.5;
                headScale = 1.8;
            } else if (type === 'ASSASSIN') {
                torsoScale = 0.6;
                limbScale = 1.5;
                headScale = 0.7;
            } else if (type === 'JUGGERNAUT') {
                torsoScale = 2.5;
                limbScale = 1.0;
                headScale = 1.5;
            } else if (type === 'GHOST') {
                torsoScale = 0.9;
                limbScale = 1.1;
                headScale = 1.0;
            } else if (type === 'HEALER') {
                torsoScale = 1.1;
                limbScale = 1.0;
                headScale = 1.1;
            } else if (type === 'SPLITTER') {
                torsoScale = 0.8;
                limbScale = 0.9;
                headScale = 0.9;
            } else if (type === 'NATRON') {
                torsoScale = 1.3;
                limbScale = 1.2;
                headScale = 1.3;
            }

            const torso = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.35 * torsoScale * scale, 0.8 * scale, 8, 16), 
                armorMat
            );
            torso.position.y = 0;
            torso.castShadow = true;
            charGroup.add(torso);

            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.25 * headScale * scale, 16, 16), 
                armorMat
            );
            head.position.y = (0.4 + 0.25 * headScale) * scale;
            head.castShadow = true;
            torso.add(head);

            const eye = new THREE.Mesh(
                new THREE.BoxGeometry(0.35 * headScale * scale, 0.05 * scale, 0.1 * scale), 
                new THREE.MeshBasicMaterial({color: eyeColor})
            );
            eye.position.set(0, 0.05 * scale, 0.22 * headScale * scale);
            head.add(eye);

            const limbGeo = new THREE.CapsuleGeometry(0.12 * scale, 0.5 * limbScale * scale, 6, 6);
            const armL = new THREE.Mesh(limbGeo, armorMat);
            const armR = new THREE.Mesh(limbGeo, armorMat);
            armL.position.set(-0.5 * torsoScale * scale, 0, 0);
            armR.position.set(0.5 * torsoScale * scale, 0, 0);
            armL.castShadow = true;
            armR.castShadow = true;
            torso.add(armL, armR);

            const legL = new THREE.Mesh(limbGeo, armorMat);
            const legR = new THREE.Mesh(limbGeo, armorMat);
            legL.position.set(-0.2 * torsoScale * scale, (-0.4 - 0.25 * limbScale) * scale, 0);
            legR.position.set(0.2 * torsoScale * scale, (-0.4 - 0.25 * limbScale) * scale, 0);
            legL.castShadow = true;
            legR.castShadow = true;
            torso.add(legL, legR);

            charGroup.userData = {
                torso, head, armL, armR, legL, legR, 
                type, scale, limbScale
            };

            return charGroup;
        }

        // --- LIGHTING CONTROLS ---
        window.updateLighting = function(type, value) {
            value = parseFloat(value);
            
            if (type === 'ambient') {
                ambientLight.intensity = value / 100;
                document.getElementById('ambient-val').innerText = (value / 100).toFixed(2);
            } else if (type === 'directional') {
                directionalLight.intensity = value / 100;
                document.getElementById('dir-val').innerText = (value / 100).toFixed(2);
            } else if (type === 'hue') {
                const color = new THREE.Color().setHSL(value / 360, 1, 0.5);
                directionalLight.color = color;
                document.getElementById('hue-val').innerText = value + '¬∞';
            }
        }

        window.updateGameSpeed = function(value) {
            gameSpeed = value / 100;
            document.getElementById('speed-val').innerText = gameSpeed.toFixed(1) + 'x';
        }

        // --- PAUSE SYSTEM ---
        window.togglePause = function() {
            isPaused = !isPaused;
            document.getElementById('pause-overlay').style.display = isPaused ? 'flex' : 'none';
            
            if (bgMusic && sfx.enabled) {
                if (isPaused) bgMusic.pause();
                else bgMusic.play().catch(e => {});
            }
            
            const btn = document.querySelector('.control-btn.pause');
            if (btn) btn.innerText = isPaused ? '‚ñ∂Ô∏è RESUME' : '‚è∏Ô∏è PAUSE';
        }

        window.showMenu = function() {
            entities.towers.forEach(t => scene.remove(t.mesh));
            entities.enemies.forEach(e => scene.remove(e.mesh));
            entities.tiles.forEach(t => scene.remove(t));
            if (neuroCore) scene.remove(neuroCore.group);
            if (portalGateway) scene.remove(portalGateway.group);
            
            entities.towers = [];
            entities.enemies = [];
            entities.projectiles = [];
            entities.tiles = [];
            neuroCore = null;
            portalGateway = null;
            
            isPaused = false;
            gameState.isGameOver = true;
            
            if (bgMusic) bgMusic.pause();
            
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('victory-screen').style.display = 'none';
            document.getElementById('build-menu').style.display = 'none';
            document.getElementById('game-controls').style.display = 'none';
            document.getElementById('light-panel').style.display = 'none';
            document.getElementById('tower-info-panel').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
            
            loadHighscores();
        }

        window.restartLevel = function() {
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('victory-screen').style.display = 'none';
            
            startGame(gameState.levelIndex);
        }

        // --- TOWER UPGRADE/DELETE ---
        window.toggleDeleteMode = function() {
            deleteMode = !deleteMode;
            const btn = document.querySelectorAll('.tower-btn')[3];
            
            if (deleteMode) {
                btn.classList.add('delete-mode');
                document.querySelectorAll('.tower-btn').forEach((b, i) => {
                    if (i < 3) b.classList.add('disabled');
                });
            } else {
                btn.classList.remove('delete-mode');
                applyTowerRestrictions();
            }
            
            hideTowerInfo();
        }

        function showTowerInfo(tower) {
            selectedTower = tower;
            const panel = document.getElementById('tower-info-panel');
            const typeData = TOWER_TYPES[tower.typeIndex];
            const currentUpgrade = typeData.upgrades[tower.level];
            
            document.getElementById('tower-info-name').innerText = typeData.name + ' HACKER';
            document.getElementById('tower-info-level').innerText = 'Level: ' + (tower.level + 1) + '/' + typeData.upgrades.length;
            document.getElementById('tower-info-damage').innerText = 'Damage: ' + currentUpgrade.damage;
            document.getElementById('tower-info-range').innerText = 'Range: ' + currentUpgrade.range;
            document.getElementById('tower-info-rate').innerText = 'Fire Rate: ' + currentUpgrade.rate + 's';
            
            const upgradeBtn = document.getElementById('upgrade-btn');
            if (tower.level < typeData.upgrades.length - 1) {
                const nextUpgrade = typeData.upgrades[tower.level + 1];
                upgradeBtn.innerText = `UPGRADE (${nextUpgrade.cost} CR)`;
                upgradeBtn.disabled = gameState.money < nextUpgrade.cost;
            } else {
                upgradeBtn.innerText = 'MAX LEVEL';
                upgradeBtn.disabled = true;
            }
            
            const sellValue = Math.floor(tower.getTotalCost() * 0.7);
            document.querySelector('.sell-btn').innerText = `SELL (${sellValue} CR)`;
            
            panel.style.display = 'block';
        }

        function hideTowerInfo() {
            selectedTower = null;
            document.getElementById('tower-info-panel').style.display = 'none';
        }

        window.upgradeTower = function() {
            if (!selectedTower) return;
            
            const typeData = TOWER_TYPES[selectedTower.typeIndex];
            if (selectedTower.level >= typeData.upgrades.length - 1) return;
            
            const nextUpgrade = typeData.upgrades[selectedTower.level + 1];
            if (gameState.money >= nextUpgrade.cost) {
                gameState.money -= nextUpgrade.cost;
                selectedTower.upgrade();
                updateUI();
                showTowerInfo(selectedTower);
                sfx.playUpgrade();
            } else {
                sfx.playError();
            }
        }

        window.sellTower = function() {
            if (!selectedTower) return;
            
            const sellValue = Math.floor(selectedTower.getTotalCost() * 0.7);
            gameState.money += sellValue;
            
            const tilePos = selectedTower.mesh.position;
            const tile = entities.tiles.find(t => 
                Math.abs(t.position.x - tilePos.x) < 0.1 && 
                Math.abs(t.position.z - tilePos.z) < 0.1
            );
            if (tile) {
                tile.userData.hasTower = false;
                tile.material.color.setHex(0x444444);
            }
            
            scene.remove(selectedTower.mesh);
            const index = entities.towers.indexOf(selectedTower);
            if (index > -1) entities.towers.splice(index, 1);
            
            hideTowerInfo();
            updateUI();
            sfx.playError();
        }

        // --- HIGHSCORE SYSTEM ---
        function saveHighscore() {
            const scores = JSON.parse(localStorage.getItem('highscores') || '[]');
            const levelName = gameState.levelIndex === 4 ? 'Sandbox' : `Level ${gameState.levelIndex + 1}`;
            
            scores.push({
                level: levelName,
                wave: gameState.wave - 1,
                date: new Date().toLocaleDateString()
            });
            
            scores.sort((a, b) => b.wave - a.wave);
            scores.splice(10);
            
            localStorage.setItem('highscores', JSON.stringify(scores));
        }

        function loadHighscores() {
            const scores = JSON.parse(localStorage.getItem('highscores') || '[]');
            const container = document.getElementById('highscore-list');
            container.innerHTML = '';
            
            if (scores.length === 0) {
                container.innerHTML = '<div style="color:#666; text-align:center; padding:20px;">No scores yet</div>';
                return;
            }
            
            scores.forEach((score, i) => {
                const entry = document.createElement('div');
                entry.className = 'highscore-entry';
                entry.innerHTML = `
                    <span>${i + 1}. ${score.level}</span>
                    <span>Wave ${score.wave}</span>
                `;
                container.appendChild(entry);
            });
        }

        // Sandbox simplified
        window.openSandbox = function() {
            sfx.playError();
            alert('Sandbox mode - simplified for space');
        }

        window.closeSandbox = function() {
            document.getElementById('sandbox-setup-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
        }

        // --- GAME LOGIC ---
        window.startGame = function(lvlIndex) {
            sfx.init();
            if (sfx.enabled) loadBackgroundMusic();
            
            // Initialize textures
            texZero = createCharTexture('0', '#00ff41');
            texOne = createCharTexture('1', '#00ff41');
            texHex = createCharTexture('‚¨°', '#00ffff');
            
            document.getElementById('start-screen').style.display = 'none';

            gameState.levelIndex = lvlIndex;
            gameState.wave = 1;
            gameState.isGameOver = false;
            isPaused = false;
            deleteMode = false;
            selectedTower = null;

            const level = LEVELS[lvlIndex];
            
            gameState.money = 450;
            gameState.lives = 20;

            const levelColor = level.color;
            bgUniforms.uColor.value.set(levelColor.r, levelColor.g, levelColor.b);
            
            entities.towers.forEach(t => scene.remove(t.mesh));
            entities.enemies.forEach(e => scene.remove(e.mesh));
            entities.tiles.forEach(t => scene.remove(t));
            if (neuroCore) scene.remove(neuroCore.group);
            if (portalGateway) scene.remove(portalGateway.group);
            
            entities.towers = [];
            entities.enemies = [];
            entities.projectiles = [];
            entities.tiles = [];

            createGrid(level);
            
            const startPoint = level.path[0];
            portalGateway = new PortalGateway(startPoint.x, startPoint.z);
            
            const endPoint = level.path[level.path.length - 1];
            neuroCore = new NeuroCore(endPoint.x, endPoint.z);
            
            updateUI();
            applyTowerRestrictions();
            
            document.getElementById('build-menu').style.display = 'flex';
            document.getElementById('game-controls').style.display = 'flex';
            document.getElementById('light-panel').style.display = 'block';
            document.getElementById('tower-info-panel').style.display = 'none';
            
            startWave();
        }

        function applyTowerRestrictions() {
            document.querySelectorAll('.tower-btn').forEach((btn, i) => {
                if (i < 3) btn.classList.remove('disabled');
            });
        }

        window.selectTower = function(index) {
            gameState.selectedTowerType = index;
            document.querySelectorAll('.tower-btn').forEach((b, i) => {
                if (i < 3) b.classList.toggle('selected', i === index);
            });
            
            if (deleteMode) toggleDeleteMode();
            
            sfx.playBuild();
        }

        function createGrid(levelData) {
            const geo = new THREE.BoxGeometry(TILE_SIZE - 0.2, 1, TILE_SIZE - 0.2);
            const pathPoints = levelData.path;

            for (let x = -12; x <= 12; x++) {
                for (let z = -12; z <= 12; z++) {
                    const isPath = checkPath(x, z, pathPoints);
                    
                    const mat = new THREE.MeshStandardMaterial({
                        color: isPath ? 0x333333 : 0x444444,
                        emissive: isPath ? levelData.color.getHex() : 0x000000,
                        emissiveIntensity: isPath ? 0.3 : 0,
                        roughness: 0.3,
                        metalness: 0.7
                    });

                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(x * TILE_SIZE, -0.5, z * TILE_SIZE);
                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    
                    mesh.userData = { isPath, gridX: x, gridZ: z, hasTower: false };
                    
                    scene.add(mesh);
                    entities.tiles.push(mesh);
                }
            }
        }

        function checkPath(x, z, points) {
            for(let i=0; i<points.length-1; i++) {
                let p1 = points[i]; let p2 = points[i+1];
                if(p1.x === p2.x && x === p1.x && z >= Math.min(p1.z,p2.z) && z <= Math.max(p1.z,p2.z)) return true;
                if(p1.z === p2.z && z === p1.z && x >= Math.min(p1.x,p2.x) && x <= Math.max(p1.x,p2.x)) return true;
            }
            return false;
        }

        // --- ENEMY CLASS (Mit NATRON) ---
        class Enemy {
            constructor(type, isBalloon = false, balloonSize = 3) {
                this.type = type;
                this.isBalloon = isBalloon;
                this.balloonSize = balloonSize;
                
                const cfg = LEVELS[gameState.levelIndex].isSandbox ? gameState.sandboxConfig : null;
                const scale = cfg ? cfg.difficultyScale : 1.0;
                
                let hp = (30 + gameState.wave * 15) * scale;
                let speed = 6;
                let charScale = 0.8;
                let color = 0xff0055;
                let eyeColor = 0xff0055;
                
                this.isPhasing = false;
                this.phaseTimer = 0;
                this.canHeal = false;
                this.healCooldown = 0;
                this.splits = 0;
                
                // NATRON SPEZIAL
                this.isNatron = false;
                this.damageByType = {}; // Tracking damage by tower type

                if (isBalloon) {
                    hp = 1;
                    speed = 4 + (4 - balloonSize) * 2;
                    charScale = 0.3 + balloonSize * 0.2;
                    const colors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00];
                    color = colors[balloonSize - 1] || 0xff0000;
                    eyeColor = 0xffffff;
                    const balloonGeo = new THREE.SphereGeometry(charScale, 16, 16);
                    const balloonMat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.5 });
                    this.mesh = new THREE.Mesh(balloonGeo, balloonMat);
                    this.mesh.castShadow = true;
                } else {
                    if (type === 'TANK') { 
                        hp *= 3; speed *= 0.6; charScale = 1.2; 
                        color = 0x00ff00; eyeColor = 0xff0000; 
                    }
                    if (type === 'SPEED') { 
                        hp *= 0.6; speed *= 1.4; charScale = 0.6; 
                        color = 0xffff00; eyeColor = 0xff8800; 
                    }
                    if (type === 'BOSS') { 
                        hp *= 10; speed *= 0.4; charScale = 1.8; 
                        color = 0xff00ff; eyeColor = 0x00ffff; 
                    }
                    if (type === 'ASSASSIN') {
                        hp *= 0.4; speed *= 2.0; charScale = 0.7;
                        color = 0x8800ff; eyeColor = 0xff00ff;
                        this.reward = 30;
                    }
                    if (type === 'JUGGERNAUT') {
                        hp *= 6; speed *= 0.3; charScale = 1.6;
                        color = 0x444444; eyeColor = 0xff0000;
                    }
                    if (type === 'GHOST') {
                        hp *= 1.5; speed *= 0.8; charScale = 0.9;
                        color = 0x00ffaa; eyeColor = 0xffffff;
                        this.canPhase = true;
                        this.phaseTimer = 3;
                    }
                    if (type === 'HEALER') {
                        hp *= 2; speed *= 0.7; charScale = 1.0;
                        color = 0x00ff88; eyeColor = 0xffff00;
                        this.canHeal = true;
                        this.healCooldown = 0;
                    }
                    if (type === 'SPLITTER') {
                        hp *= 1.5; speed *= 0.9; charScale = 0.9;
                        color = 0xff8800; eyeColor = 0xffff00;
                        this.canSplit = true;
                        this.splits = 0;
                        this.maxSplits = 2;
                    }
                    // NEUER GEGNER: NATRON
                    if (type === 'NATRON') {
                        hp *= 4; speed *= 0.7; charScale = 1.1;
                        color = 0xffaa00; eyeColor = 0xff0000;
                        this.isNatron = true;
                        this.reward = 50;
                    }

                    this.mesh = createCharacter(type, charScale, color, eyeColor);
                }
                
                const start = LEVELS[gameState.levelIndex].path[0];
                const yOffset = isBalloon ? charScale + 0.5 : charScale * 1.5;
                this.mesh.position.set(start.x * TILE_SIZE, yOffset, start.z * TILE_SIZE);
                
                this.hp = hp;
                this.maxHp = hp;
                this.speed = speed;
                this.pathIndex = 0;
                this.dead = false;
                this.animTime = Math.random() * 100;
                this.reward = this.reward || 15;
                
                if (!isBalloon || balloonSize > 1) {
                    const barGeo = new THREE.PlaneGeometry(2, 0.2);
                    const barMat = new THREE.MeshBasicMaterial({color: 0x00ff00});
                    this.hpBar = new THREE.Mesh(barGeo, barMat);
                    this.hpBar.position.y = charScale * 2.5;
                    this.mesh.add(this.hpBar);
                }

                scene.add(this.mesh);
            }

            update(dt) {
                if (this.dead) return;
                
                dt *= gameSpeed;
                this.animTime += dt;
                
                if (this.canPhase) {
                    this.phaseTimer -= dt;
                    if (this.phaseTimer <= 0) {
                        this.isPhasing = !this.isPhasing;
                        this.phaseTimer = this.isPhasing ? 2 : 3;
                        
                        if (this.isPhasing) {
                            sfx.playPhase();
                            this.mesh.traverse(child => {
                                if (child.material) {
                                    child.material.transparent = true;
                                    child.material.opacity = 0.3;
                                }
                            });
                        } else {
                            this.mesh.traverse(child => {
                                if (child.material) {
                                    child.material.opacity = 1.0;
                                }
                            });
                        }
                    }
                }
                
                if (this.canHeal) {
                    this.healCooldown -= dt;
                    if (this.healCooldown <= 0) {
                        this.healCooldown = 3;
                        entities.enemies.forEach(e => {
                            if (e !== this && !e.dead && this.mesh.position.distanceTo(e.mesh.position) < 10) {
                                e.hp = Math.min(e.maxHp, e.hp + e.maxHp * 0.2);
                                if (e.hpBar) {
                                    const pct = e.hp / e.maxHp;
                                    e.hpBar.scale.x = pct;
                                    e.hpBar.material.color.setHSL(pct * 0.3, 1, 0.5);
                                }
                                sfx.playHeal();
                                spawnParticles(e.mesh.position, 0x00ff88, 5);
                            }
                        });
                    }
                }
                
                const path = LEVELS[gameState.levelIndex].path;
                if (this.pathIndex >= path.length - 1) {
                    this.hitBase();
                    return;
                }

                const targetGrid = path[this.pathIndex + 1];
                const targetPos = new THREE.Vector3(targetGrid.x * TILE_SIZE, this.mesh.position.y, targetGrid.z * TILE_SIZE);
                
                const dir = new THREE.Vector3().subVectors(targetPos, this.mesh.position);
                const dist = dir.length();

                if (dist < 0.2) {
                    this.pathIndex++;
                } else {
                    dir.normalize();
                    
                    const angle = Math.atan2(dir.x, dir.z);
                    this.mesh.rotation.y = angle;
                    
                    this.mesh.position.add(dir.multiplyScalar(this.speed * dt));
                    
                    if (this.mesh.userData.legL && !this.isBalloon) {
                        const parts = this.mesh.userData;
                        parts.legL.rotation.x = Math.sin(this.animTime * 12) * 0.7;
                        parts.legR.rotation.x = Math.cos(this.animTime * 12) * 0.7;
                        parts.armL.rotation.x = Math.cos(this.animTime * 12) * 0.5;
                        parts.armR.rotation.x = Math.sin(this.animTime * 12) * 0.5;
                        parts.torso.position.y = Math.sin(this.animTime * 24) * 0.05 * parts.scale;
                    } else if (this.isBalloon) {
                        this.mesh.rotation.y += dt * 2;
                    }
                }
            }

            takeDamage(dmg, towerType) {
                if (this.isPhasing) return;
                
                // NATRON LOGIK
                if (this.isNatron && towerType !== undefined) {
                    if (!this.damageByType[towerType]) {
                        this.damageByType[towerType] = 0;
                    }
                    
                    const maxDamageFromType = this.maxHp * 0.35;
                    const remainingAllowedDamage = maxDamageFromType - this.damageByType[towerType];
                    const actualDamage = Math.min(dmg, remainingAllowedDamage);
                    
                    this.damageByType[towerType] += actualDamage;
                    this.hp -= actualDamage;
                } else {
                    this.hp -= dmg;
                }
                
                if (this.hpBar) {
                    const pct = Math.max(0, this.hp / this.maxHp);
                    this.hpBar.scale.x = pct;
                    this.hpBar.material.color.setHSL(pct * 0.3, 1, 0.5);
                }
                
                if (this.canSplit && this.splits < this.maxSplits && this.hp > 0 && this.hp < this.maxHp * 0.5) {
                    this.splits++;
                    setTimeout(() => {
                        const newEnemy = new Enemy(this.type);
                        newEnemy.hp = this.maxHp * 0.3;
                        newEnemy.maxHp = this.maxHp * 0.3;
                        newEnemy.mesh.position.copy(this.mesh.position);
                        newEnemy.mesh.position.x += (Math.random() - 0.5) * 3;
                        newEnemy.mesh.position.z += (Math.random() - 0.5) * 3;
                        newEnemy.pathIndex = this.pathIndex;
                        newEnemy.canSplit = false;
                        entities.enemies.push(newEnemy);
                        sfx.playResonantRing();
                    }, 100);
                }

                if (this.hp <= 0 && !this.dead) {
                    this.dead = true;
                    
                    if (this.isBalloon && this.balloonSize > 1) {
                        sfx.playResonantRing();
                        setTimeout(() => {
                            for (let i = 0; i < 2; i++) {
                                const newBalloon = new Enemy('NORMAL', true, this.balloonSize - 1);
                                newBalloon.mesh.position.copy(this.mesh.position);
                                newBalloon.mesh.position.x += (i - 0.5) * 2;
                                newBalloon.pathIndex = this.pathIndex;
                                entities.enemies.push(newBalloon);
                            }
                        }, 100);
                    } else {
                        sfx.playResonantRing();
                    }
                    
                    const moneyGain = this.isBalloon ? 5 * this.balloonSize : (this.type === 'BOSS' ? 100 : this.reward);
                    gameState.money += moneyGain;
                    updateUI();
                    
                    const particleColor = this.mesh.material ? this.mesh.material.color.getHex() : 0xff0055;
                    spawnParticles(this.mesh.position, particleColor, this.isBalloon ? 5 : 10);
                    shake.amount = this.isBalloon ? 0.1 : 0.3;
                    scene.remove(this.mesh);
                }
            }

            hitBase() {
                this.dead = true;
                scene.remove(this.mesh);
                
                if (neuroCore && !neuroCore.destroyed) {
                    neuroCore.takeDamage();
                }
                
                gameState.lives--;
                updateUI();
            }
        }

        // --- HACKER TOWER CLASS ---
        class Tower {
            constructor(x, z, typeIndex) {
                this.typeIndex = typeIndex;
                this.level = 0;
                const typeData = TOWER_TYPES[typeIndex];
                this.typeData = typeData;
                this.data = typeData.upgrades[0];
                
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, 1, z);
                this.mesh.userData.tower = this;

                this.createGeometry();
                
                this.mesh.scale.set(0.1,0.1,0.1);
                this.cooldown = 0;
                this.animTime = 0;
            }

            createGeometry() {
                while(this.mesh.children.length > 0) {
                    this.mesh.remove(this.mesh.children[0]);
                }

                const size = 1 + this.level * 0.15;
                
                // Core (Pulsierender Kern)
                const coreGeo = new THREE.IcosahedronGeometry(0.8 * size, 0);
                const coreMat = new THREE.MeshBasicMaterial({ 
                    color: this.data.color, 
                    wireframe: true 
                });
                this.hackerCore = new THREE.Mesh(coreGeo, coreMat);
                this.hackerCore.position.y = 1;
                this.mesh.add(this.hackerCore);

                // Data Cloud
                const cloudCount = 20 + this.level * 10;
                const cloudGeo = new THREE.BufferGeometry();
                const cloudPos = new Float32Array(cloudCount * 3);
                for(let i=0; i<cloudCount*3; i++) {
                    cloudPos[i] = (Math.random()-0.5) * 3 * size;
                }
                cloudGeo.setAttribute('position', new THREE.BufferAttribute(cloudPos, 3));
                const cloudMat = new THREE.PointsMaterial({ 
                    color: this.data.color, 
                    size: 0.3, 
                    transparent: true, 
                    opacity: 0.7 
                });
                this.dataCloud = new THREE.Points(cloudGeo, cloudMat);
                this.dataCloud.position.y = 1;
                this.mesh.add(this.dataCloud);

                // Base
                const baseGeo = new THREE.CylinderGeometry(1.5 * size, 2 * size, 0.5, 6);
                const baseMat = new THREE.MeshStandardMaterial({ 
                    color: 0x222222,
                    emissive: this.data.color,
                    emissiveIntensity: 0.3
                });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 0.25;
                this.mesh.add(base);

                // Light
                this.light = new THREE.PointLight(this.data.color, 1 + this.level * 0.5, 8);
                this.light.position.y = 1;
                this.mesh.add(this.light);

                scene.add(this.mesh);
            }

            upgrade() {
                if (this.level < this.typeData.upgrades.length - 1) {
                    this.level++;
                    this.data = this.typeData.upgrades[this.level];
                    this.createGeometry();
                }
            }

            getTotalCost() {
                let total = this.typeData.baseCost;
                for (let i = 1; i <= this.level; i++) {
                    total += this.typeData.upgrades[i].cost;
                }
                return total;
            }

            update(dt) {
                this.mesh.scale.lerp(new THREE.Vector3(1,1,1), dt * 10);
                this.cooldown -= dt;
                this.animTime += dt;

                // Hacker Animation
                if (this.hackerCore) {
                    this.hackerCore.rotation.y = this.animTime * 2;
                    this.hackerCore.rotation.z = this.animTime;
                    const pulse = 1 + Math.sin(this.animTime * 10) * 0.1;
                    this.hackerCore.scale.setScalar(pulse);
                }
                
                if (this.dataCloud) {
                    this.dataCloud.rotation.y = -this.animTime * 0.5;
                }

                let target = null;
                let minDist = this.data.range;

                for (const e of entities.enemies) {
                    if (e.dead || e.isPhasing) continue;
                    const d = this.mesh.position.distanceTo(e.mesh.position);
                    if (d < minDist) {
                        minDist = d;
                        target = e;
                    }
                }

                if (target) {
                    if (this.cooldown <= 0) {
                        this.shoot(target);
                        this.cooldown = this.data.rate;
                    }
                }
            }

            shoot(target) {
                // UNTERSCHIEDLICHE SOUNDS F√úR JEDEN HACKER-TYP
                if(this.typeIndex === 0) sfx.playSonicWave();
                else if(this.typeIndex === 1) sfx.playTremoloWave();
                else if(this.typeIndex === 2) sfx.playUnderwaterEcho();

                // Flash effect
                if (this.light) {
                    this.light.intensity = 3;
                    setTimeout(() => { this.light.intensity = 1 + this.level * 0.5; }, 100);
                }

                entities.projectiles.push(new Projectile(
                    this.mesh.position.clone().add(new THREE.Vector3(0, 1, 0)),
                    target,
                    this.data,
                    this.typeData.projectileSpeed,
                    this.typeIndex  // Pass tower type for Natron
                ));
            }
        }

        // --- PROJECTILE CLASS (BIT SPRITES) ---
        class Projectile {
            constructor(pos, target, data, speed, towerType) {
                this.pos = pos;
                this.target = target;
                this.data = data;
                this.speed = speed;
                this.towerType = towerType; // For Natron damage tracking
                
                // Random bit: 0 or 1
                const tex = Math.random() > 0.5 ? texZero : texOne;
                const mat = new THREE.SpriteMaterial({ 
                    map: tex, 
                    color: data.color, 
                    transparent: true 
                });
                this.mesh = new THREE.Sprite(mat);
                this.mesh.position.copy(pos);
                this.mesh.scale.set(1, 1, 1);
                
                this.active = true;
                scene.add(this.mesh);

                this.light = new THREE.PointLight(data.color, 0.5, 3);
                this.mesh.add(this.light);
            }

            update(dt) {
                if (!this.active) return;
                
                if ((this.target.dead || this.target.isPhasing) && !this.data.aoe) {
                    this.active = false; 
                    scene.remove(this.mesh); 
                    return;
                }

                const targetPos = this.target.mesh.position.clone();
                targetPos.y += 1;
                const dir = new THREE.Vector3().subVectors(targetPos, this.mesh.position).normalize();
                
                this.mesh.position.add(dir.multiplyScalar(this.speed * dt));

                if (this.mesh.position.distanceTo(targetPos) < 1.0) {
                    this.hit();
                }
            }

            hit() {
                this.active = false;
                scene.remove(this.mesh);
                
                if (this.data.aoe) {
                    spawnParticles(this.mesh.position, this.data.color, 20);
                    sfx.playResonantRing();
                    entities.enemies.forEach(e => {
                        if (e.mesh.position.distanceTo(this.mesh.position) < this.data.aoe) {
                            e.takeDamage(this.data.damage, this.towerType);
                        }
                    });
                } else {
                    if (!this.target.dead && !this.target.isPhasing) {
                        this.target.takeDamage(this.data.damage, this.towerType);
                    }
                }
            }
        }

        // --- SYSTEMS ---
        function spawnParticles(pos, color, count) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.position.x += (Math.random()-0.5);
                mesh.position.z += (Math.random()-0.5);
                
                const vel = new THREE.Vector3(
                    (Math.random()-0.5) * 10,
                    (Math.random()) * 10,
                    (Math.random()-0.5) * 10
                );
                
                entities.particles.push({ mesh, vel, life: 1.0 });
                scene.add(mesh);
            }
        }

        function startWave() {
            if (gameState.isGameOver) return;
            
            const msg = document.getElementById('msg-area');
            msg.innerText = "WAVE " + gameState.wave;
            msg.style.opacity = 1;
            setTimeout(() => msg.style.opacity = 0, 2000);

            const level = LEVELS[gameState.levelIndex];

            let baseCount = 5;
            let diffScale = 1.0;
            let total = Math.floor(baseCount + (gameState.wave - 1) * 1.5 * diffScale);
            
            const intervalTime = Math.max(200, 1500 - gameState.wave * 50);
            let count = 0;

            const spawner = setInterval(() => {
                if (gameState.isGameOver || isPaused) { 
                    if (gameState.isGameOver) clearInterval(spawner);
                    return;
                }
                
                let type = 'NORMAL';
                let isBalloon = level.isBalloonLevel || false;
                
                if (!isBalloon) {
                    const r = Math.random();
                    
                    if (gameState.wave > 3 && r > 0.85) type = 'SPEED';
                    else if (gameState.wave > 5 && r > 0.9) type = 'TANK';
                    
                    // New enemy types
                    if (gameState.wave >= 7) {
                        if (r < 0.05) type = 'ASSASSIN';
                        else if (r > 0.93 && r < 0.96) type = 'GHOST';
                        else if (r > 0.96 && r < 0.98) type = 'SPLITTER';
                    }
                    if (gameState.wave >= 10) {
                        if (r > 0.88 && r < 0.91) type = 'JUGGERNAUT';
                        else if (r > 0.98 && r < 0.99) type = 'HEALER';
                        else if (r > 0.99) type = 'NATRON'; // NATRON spawnt selten
                    }
                    
                    if (gameState.wave % 5 === 0 && count === total - 1) type = 'BOSS';
                }

                if (isBalloon) {
                    const size = Math.min(4, Math.floor(1 + gameState.wave * 0.3));
                    entities.enemies.push(new Enemy(type, true, size));
                } else {
                    entities.enemies.push(new Enemy(type));
                }
                
                count++;

                if (count >= total) {
                    clearInterval(spawner);
                    checkWaveEnd();
                }
            }, intervalTime);
        }

        function checkWaveEnd() {
            const check = setInterval(() => {
                if (gameState.isGameOver) { clearInterval(check); return; }
                if (isPaused) return;
                
                if (entities.enemies.length === 0) {
                    clearInterval(check);
                    gameState.wave++;
                    updateUI();
                    
                    setTimeout(startWave, 3000);
                }
            }, 1000);
        }

        function victoryScreen() {
            gameState.isGameOver = true;
            saveHighscore();
            document.getElementById('victory-msg').innerText = `Completed ${gameState.wave - 1} Waves!`;
            document.getElementById('victory-screen').style.display = 'flex';
            if (bgMusic) bgMusic.pause();
        }

        function onPointerDown(e) {
            sfx.init();
            
            if (gameState.isGameOver || isPaused) return;
            if (e.target.tagName !== 'CANVAS') return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const towerMeshes = entities.towers.map(t => t.mesh);
            const towerIntersects = raycaster.intersectObjects(towerMeshes, true);
            
            if (towerIntersects.length > 0) {
                let tower = null;
                let obj = towerIntersects[0].object;
                while (obj && !tower) {
                    if (obj.userData.tower) tower = obj.userData.tower;
                    obj = obj.parent;
                }
                
                if (tower) {
                    if (deleteMode) {
                        selectedTower = tower;
                        sellTower();
                    } else {
                        showTowerInfo(tower);
                    }
                    return;
                }
            }

            const intersects = raycaster.intersectObjects(entities.tiles);
            if (intersects.length > 0) {
                hideTowerInfo();
                
                if (deleteMode) return;
                
                const obj = intersects[0].object;
                const typeData = TOWER_TYPES[gameState.selectedTowerType];
                const cost = typeData.baseCost;

                if (!obj.userData.isPath && !obj.userData.hasTower && gameState.money >= cost) {
                    gameState.money -= cost;
                    obj.userData.hasTower = true;
                    obj.material.color.setHex(0x111111);
                    
                    entities.towers.push(new Tower(obj.position.x, obj.position.z, gameState.selectedTowerType));
                    sfx.playBuild();
                    updateUI();
                } else if (gameState.money < cost) {
                    sfx.playError();
                }
            } else {
                hideTowerInfo();
            }
        }

        function updateUI() {
            document.getElementById('money-val').innerText = gameState.money;
            document.getElementById('lives-val').innerText = Math.max(0, gameState.lives * 5) + "%";
            document.getElementById('wave-val').innerText = gameState.wave;
        }

        function endGame() {
            gameState.isGameOver = true;
            saveHighscore();
            document.getElementById('final-score').innerText = "WAVES SURVIVED: " + (gameState.wave - 1);
            document.getElementById('game-over-screen').style.display = 'flex';
            if (bgMusic) bgMusic.pause();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- INIT ---
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.012);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            controls.minDistance = 10;
            controls.maxDistance = 80;

            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
            fillLight.position.set(-20, 30, -20);
            scene.add(fillLight);

            const bgGeo = new THREE.PlaneGeometry(200, 200);
            const bgMesh = new THREE.Mesh(bgGeo, bgMaterial);
            bgMesh.rotation.x = -Math.PI / 2;
            bgMesh.position.y = -2;
            scene.add(bgMesh);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onResize);
            window.addEventListener('pointerdown', onPointerDown);
            
            loadHighscores();
            animate();
        }

        // --- MAIN LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = isPaused ? 0 : clock.getDelta();
            const time = clock.getElapsedTime();

            bgUniforms.uTime.value = time;

            if (shake.amount > 0) {
                camera.position.x += (Math.random() - 0.5) * shake.amount;
                camera.position.y += (Math.random() - 0.5) * shake.amount;
                camera.position.z += (Math.random() - 0.5) * shake.amount;
                shake.amount = Math.max(0, shake.amount - (isPaused ? 0 : dt * 2));
            }
            controls.update();

            if (portalGateway && !gameState.isGameOver) {
                portalGateway.update(dt);
            }

            if (neuroCore && !gameState.isGameOver) {
                neuroCore.update(dt);
            }

            if (!gameState.isGameOver && !isPaused) {
                entities.enemies.forEach((e, i) => {
                    e.update(dt);
                    if (e.dead) entities.enemies.splice(i, 1);
                });

                entities.towers.forEach(t => t.update(dt));

                entities.projectiles.forEach((p, i) => {
                    p.update(dt);
                    if (!p.active) entities.projectiles.splice(i, 1);
                });
            }

            entities.particles.forEach((p, i) => {
                p.life -= (isPaused ? 0 : dt);
                p.vel.y -= (isPaused ? 0 : 20 * dt);
                p.mesh.position.add(p.vel.clone().multiplyScalar(isPaused ? 0 : dt));
                p.mesh.rotation.x += (isPaused ? 0 : dt * 5);
                p.mesh.scale.multiplyScalar(isPaused ? 1 : 0.95);
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    entities.particles.splice(i, 1);
                }
            });

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
