<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>NEON DEFENSE: ARCADE EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Orbitron', sans-serif; user-select: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        
        .stat-box {
            text-align: center; color: #fff; text-shadow: 0 0 10px currentColor;
            background: rgba(0, 10, 20, 0.6); border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 20px; border-radius: 4px; transform: skewX(-10deg);
        }
        .stat-label { font-size: 10px; color: #aaa; letter-spacing: 2px; }
        .stat-value { font-size: 28px; font-weight: 900; }

        #money-display { color: #f0e; border-color: #f0e; }
        #lives-display { color: #0ff; border-color: #0ff; }
        #wave-display { color: #ff0; border-color: #ff0; }

        .game-controls {
            position: absolute; top: 120px; right: 20px;
            display: flex; flex-direction: column; gap: 10px; pointer-events: auto;
        }
        
        .control-btn {
            padding: 10px 20px; background: rgba(0,0,0,0.8); border: 2px solid #0ff;
            color: #0ff; font-family: 'Orbitron'; font-weight: bold; cursor: pointer;
            transition: 0.2s; font-size: 14px;
        }
        .control-btn:hover { background: #0ff; color: #000; box-shadow: 0 0 20px #0ff; }
        .control-btn.pause { border-color: #ff0; color: #ff0; }
        .control-btn.pause:hover { background: #ff0; }

        .light-panel {
            position: absolute; top: 80px; left: 20px; pointer-events: auto;
            background: rgba(0,0,0,0.9); padding: 15px; border-radius: 10px;
            border: 1px solid #0ff; min-width: 200px; max-height: 80vh; overflow-y: auto;
        }
        .light-panel h4 { color: #0ff; margin: 0 0 10px 0; font-size: 14px; }
        .light-slider { width: 100%; margin: 5px 0; }
        
        .toggle-btn {
            width: 100%; padding: 8px; margin: 5px 0;
            background: #222; border: 2px solid #555; color: #fff;
            font-family: 'Orbitron'; font-weight: bold; cursor: pointer;
            transition: 0.2s; font-size: 12px;
        }
        .toggle-btn.active { background: #0f0; color: #000; border-color: #0f0; }
        .toggle-btn:hover { border-color: #0ff; }

        #build-menu {
            pointer-events: auto;
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px;
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 10px; border: 1px solid #333;
        }
        
        .tower-btn {
            width: 80px; height: 80px;
            background: #111; border: 2px solid #333; color: #fff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s; font-family: 'Orbitron'; position: relative;
        }
        .tower-btn:hover { transform: scale(1.1); border-color: #fff; box-shadow: 0 0 15px #fff; }
        .tower-btn.selected { border-color: #0f0; background: #002200; box-shadow: 0 0 10px #0f0; }
        .tower-btn.disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }
        .tower-price { font-size: 12px; color: #ff0; margin-top: 5px; }
        .tower-name { font-size: 10px; font-weight: bold; }
        
        .delete-mode { border-color: #f00 !important; background: #220000 !important; }
        .delete-mode:hover { box-shadow: 0 0 10px #f00 !important; }

        .tower-info-panel {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); padding: 15px; border-radius: 10px;
            border: 2px solid #0ff; pointer-events: auto; min-width: 300px;
            display: none;
        }
        .tower-info-panel h3 { color: #0ff; margin: 0 0 10px 0; }
        .tower-stat { color: #fff; margin: 5px 0; font-size: 14px; }
        .upgrade-btn, .sell-btn, .repair-btn {
            width: 100%; padding: 10px; margin-top: 5px;
            border: none; font-family: 'Orbitron'; font-weight: bold; cursor: pointer;
            transition: 0.2s;
        }
        .upgrade-btn { background: #0f0; color: #000; }
        .upgrade-btn:hover { box-shadow: 0 0 20px #0f0; transform: scale(1.05); }
        .upgrade-btn:disabled { background: #333; color: #666; cursor: not-allowed; }
        .sell-btn { background: #f00; color: #fff; }
        .sell-btn:hover { box-shadow: 0 0 20px #f00; }
        .repair-btn { background: #ff0; color: #000; }
        .repair-btn:hover { box-shadow: 0 0 20px #ff0; }

        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; backdrop-filter: blur(5px); z-index: 10;
            overflow-y: auto;
        }
        
        h1 { 
            font-size: 60px; margin: 0; 
            background: linear-gradient(to right, #0ff, #f0e); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; 
            text-shadow: 0 0 30px rgba(0,255,255,0.5); 
        }
        h2 { color: #fff; margin-bottom: 30px; }
        h3 { color: #0ff; margin: 15px 0 5px 0; }
        
        .btn-main {
            padding: 15px 40px; font-size: 24px; font-family: 'Orbitron'; font-weight: bold;
            background: transparent; color: #0ff; border: 2px solid #0ff;
            cursor: pointer; text-transform: uppercase; margin: 10px;
            transition: 0.2s; position: relative; overflow: hidden;
        }
        .btn-main:hover { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
        
        .btn-small {
            padding: 8px 20px; font-size: 14px; font-family: 'Orbitron'; font-weight: bold;
            background: transparent; color: #f0e; border: 2px solid #f0e;
            cursor: pointer; text-transform: uppercase; margin: 5px;
            transition: 0.2s;
        }
        .btn-small:hover { background: #f0e; color: #000; box-shadow: 0 0 20px #f0e; }
        
        .level-select-container { display: flex; gap: 20px; margin-top: 20px; flex-wrap: wrap; justify-content: center; }
        .level-card {
            width: 150px; height: 100px; border: 1px solid #555; background: #111;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            color: #888; transition: 0.3s; text-align: center; padding: 10px;
        }
        .level-card:hover { border-color: #f0e; color: #f0e; transform: translateY(-5px); }
        .level-card.locked { opacity: 0.3; pointer-events: none; }
        .level-card.sandbox { border-color: #0f0; color: #0f0; }
        .level-card.sandbox:hover { box-shadow: 0 0 20px #0f0; }

        .sandbox-container {
            display: flex; gap: 20px; width: 90%; max-width: 1200px;
            background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;
        }
        .sandbox-left { flex: 1; }
        .sandbox-right { flex: 2; }
        
        .sandbox-section {
            background: rgba(0,40,0,0.3); padding: 15px; border-radius: 8px;
            border: 1px solid #0f0; margin-bottom: 15px;
        }
        .sandbox-section h4 { color: #0f0; margin: 0 0 10px 0; font-size: 14px; }
        .sandbox-label { color: #0ff; font-size: 12px; margin: 10px 0 5px 0; display: block; }
        .sandbox-input {
            width: 100%; padding: 8px; background: #111; border: 1px solid #0f0;
            color: #0ff; font-family: 'Orbitron'; border-radius: 4px;
        }

        .path-editor {
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px;
            border: 1px solid #0f0;
        }
        .path-grid {
            display: grid; grid-template-columns: repeat(17, 25px);
            gap: 2px; margin: 10px 0;
        }
        .path-cell {
            width: 25px; height: 25px; background: #222; border: 1px solid #444;
            cursor: pointer; transition: 0.1s;
        }
        .path-cell:hover { background: #555; }
        .path-cell.path { background: #0f0; box-shadow: 0 0 5px #0f0; }
        .path-cell.start { background: #0ff; box-shadow: 0 0 5px #0ff; }
        .path-cell.end { background: #f0f; box-shadow: 0 0 5px #f0f; }
        .path-cell.invalid { background: #f00; }

        .preset-container {
            display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;
        }
        .preset-btn {
            padding: 8px 15px; background: #222; border: 1px solid #0f0;
            color: #0f0; font-family: 'Orbitron'; cursor: pointer;
            transition: 0.2s; font-size: 11px;
        }
        .preset-btn:hover { background: #0f0; color: #000; }

        .highscore-panel {
            background: rgba(20,20,20,0.9); padding: 20px; border-radius: 10px;
            border: 1px solid #ff0; margin-top: 20px; max-width: 400px;
        }
        .highscore-entry {
            display: flex; justify-content: space-between; padding: 5px 0;
            color: #fff; border-bottom: 1px solid #333;
        }
        .highscore-entry:first-child { color: #ff0; font-weight: bold; }

        #msg-area {
            position: absolute; top: 20%; width: 100%; text-align: center;
            font-size: 40px; font-weight: bold; color: #fff; pointer-events: none;
            text-shadow: 0 0 20px #fff; opacity: 0; transition: opacity 0.5s;
        }

        .pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(10px);
            display: none; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 15;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-box" id="lives-display">
                <div class="stat-label">NEURO-CORE INTEGRITY</div>
                <div class="stat-value" id="lives-val">100%</div>
            </div>
            <div class="stat-box" id="wave-display">
                <div class="stat-label">WAVE</div>
                <div class="stat-value" id="wave-val">1</div>
            </div>
            <div class="stat-box" id="money-display">
                <div class="stat-label">CREDITS</div>
                <div class="stat-value" id="money-val">0</div>
            </div>
        </div>

        <div class="game-controls" style="display:none;" id="game-controls">
            <button class="control-btn pause" onclick="togglePause()">‚è∏Ô∏è PAUSE</button>
            <button class="control-btn" onclick="showMenu()">üìã MENU</button>
        </div>

        <div class="light-panel" style="display:none;" id="light-panel">
            <h4>‚öôÔ∏è SETTINGS</h4>
            
            <button class="toggle-btn active" id="sound-toggle" onclick="toggleSound()">üîä SOUND: ON</button>
            
            <label style="color:#fff; font-size:12px; margin-top:10px; display:block;">üí° Ambient: <span id="ambient-val">0.4</span></label>
            <input type="range" class="light-slider" min="0" max="100" value="40" oninput="updateLighting('ambient', this.value)">
            
            <label style="color:#fff; font-size:12px; margin-top:10px; display:block;">‚òÄÔ∏è Directional: <span id="dir-val">1.2</span></label>
            <input type="range" class="light-slider" min="0" max="200" value="120" oninput="updateLighting('directional', this.value)">
            
            <label style="color:#fff; font-size:12px; margin-top:10px; display:block;">üé® Color Hue: <span id="hue-val">180¬∞</span></label>
            <input type="range" class="light-slider" min="0" max="360" value="180" oninput="updateLighting('hue', this.value)">
            
            <label style="color:#fff; font-size:12px; margin-top:10px; display:block;">‚ö° Game Speed: <span id="speed-val">1.0x</span></label>
            <input type="range" class="light-slider" min="10" max="200" value="100" oninput="updateGameSpeed(this.value)">
        </div>

        <div id="msg-area">WAVE COMPLETE</div>

        <div id="build-menu" style="display:none;">
            <div class="tower-btn selected" data-type="0" onclick="selectTower(0)">
                <div class="tower-name">HACKER-0</div>
                <div style="font-size:20px;">üë®‚Äçüíª</div>
                <div class="tower-price">50 CR</div>
            </div>
            <div class="tower-btn" data-type="1" onclick="selectTower(1)">
                <div class="tower-name">HACKER-1</div>
                <div style="font-size:20px;">üéØ</div>
                <div class="tower-price">120 CR</div>
            </div>
            <div class="tower-btn" data-type="2" onclick="selectTower(2)">
                <div class="tower-name">HACKER-X</div>
                <div style="font-size:20px;">üíª</div>
                <div class="tower-price">200 CR</div>
            </div>
            <div class="tower-btn" onclick="toggleDeleteMode()">
                <div class="tower-name">DELETE</div>
                <div style="font-size:20px;">üóëÔ∏è</div>
                <div class="tower-price">SELL</div>
            </div>
        </div>

        <div class="tower-info-panel" id="tower-info-panel">
            <h3 id="tower-info-name">Hacker</h3>
            <div class="tower-stat" id="tower-info-level">Level: 1</div>
            <div class="tower-stat" id="tower-info-damage">Damage: 10</div>
            <div class="tower-stat" id="tower-info-range">Range: 15</div>
            <div class="tower-stat" id="tower-info-rate">Fire Rate: 0.6s</div>
            <button class="upgrade-btn" id="upgrade-btn" onclick="upgradeTower()">UPGRADE (100 CR)</button>
            <button class="sell-btn" onclick="sellTower()">SELL (25 CR)</button>
            <button class="repair-btn" id="repair-btn" onclick="repairTile()" style="display:none;">REPAIR TILE (200 CR)</button>
        </div>
    </div>

    <div class="pause-overlay" id="pause-overlay">
        <div style="text-align: center;">
            <h1 style="-webkit-text-fill-color: #ff0;">‚è∏Ô∏è PAUSED</h1>
            <button class="btn-main" onclick="togglePause()">RESUME</button>
            <button class="btn-main" onclick="restartLevel()">RESTART</button>
            <button class="btn-main" onclick="showMenu()">MAIN MENU</button>
        </div>
    </div>

    <div id="start-screen" class="overlay-screen">
        <h1>NEON DEFENSE</h1>
        <h2>PROTECT THE NEURO-CORE</h2>
        <div class="level-select-container">
            <div class="level-card" onclick="startGame(0)">LEVEL 1<br>The Snake</div>
            <div class="level-card" onclick="startGame(1)">LEVEL 2<br>The Spiral</div>
            <div class="level-card" onclick="startGame(2)">LEVEL 3<br>ZigZag</div>
            <div class="level-card" onclick="startGame(3)">LEVEL 4<br>Balloons üéà</div>
            <div class="level-card sandbox" onclick="openSandbox()">SANDBOX<br>MODE üõ†Ô∏è</div>
        </div>

        <div class="highscore-panel">
            <h3 style="text-align:center;">üèÜ HIGH SCORES</h3>
            <div id="highscore-list"></div>
        </div>
    </div>

    <div id="sandbox-setup-screen" class="overlay-screen" style="display:none;">
        <h1 style="-webkit-text-fill-color: #0f0;">üõ†Ô∏è SANDBOX MODE</h1>
        <h2>Customize Your Challenge</h2>
        
        <div class="sandbox-container">
            <div class="sandbox-left">
                <div class="sandbox-section">
                    <h4>üí∞ Economy</h4>
                    <label class="sandbox-label">Starting Credits</label>
                    <input type="number" class="sandbox-input" id="sandbox-money" value="1000" min="0" max="10000" step="100">
                    
                    <label class="sandbox-label">Difficulty Scale</label>
                    <input type="range" class="sandbox-input" id="sandbox-difficulty" min="10" max="300" value="100">
                    <span style="color:#0ff;" id="sandbox-difficulty-val">1.0x</span>
                </div>

                <div class="sandbox-section">
                    <h4>üëæ Enemies</h4>
                    <label class="sandbox-label">Enemies Per Wave</label>
                    <input type="number" class="sandbox-input" id="sandbox-enemy-count" value="10" min="1" max="50">
                    
                    <label class="sandbox-label">Boss Wave Interval</label>
                    <input type="number" class="sandbox-input" id="sandbox-boss-interval" value="5" min="1" max="20">
                    
                    <label class="sandbox-label">Max Waves (0 = ‚àû)</label>
                    <input type="number" class="sandbox-input" id="sandbox-max-waves" value="0" min="0" max="100">
                </div>

                <div class="sandbox-section">
                    <h4>üé® Theme Color</h4>
                    <label class="sandbox-label">Hue</label>
                    <input type="range" class="sandbox-input" id="sandbox-hue" min="0" max="360" value="120">
                    <div style="width:100%; height:30px; border-radius:5px; margin-top:10px;" id="sandbox-color-preview"></div>
                </div>

                <div class="sandbox-section">
                    <h4>‚öîÔ∏è Enemy Mix</h4>
                    <label class="sandbox-label">Normal %</label>
                    <input type="range" class="sandbox-input" id="sandbox-normal" min="0" max="100" value="50">
                    <span style="color:#0ff;" id="sandbox-normal-val">50%</span>
                    
                    <label class="sandbox-label">Speed %</label>
                    <input type="range" class="sandbox-input" id="sandbox-speed" min="0" max="100" value="30">
                    <span style="color:#0ff;" id="sandbox-speed-val">30%</span>
                    
                    <label class="sandbox-label">Tank %</label>
                    <input type="range" class="sandbox-input" id="sandbox-tank" min="0" max="100" value="20">
                    <span style="color:#0ff;" id="sandbox-tank-val">20%</span>
                </div>
            </div>

            <div class="sandbox-right">
                <div class="path-editor">
                    <h4 style="color:#0f0; margin: 0 0 10px 0;">üõ§Ô∏è Path Editor</h4>
                    <div style="color:#888; font-size:11px; margin-bottom:10px;">
                        Click to draw path. Start (cyan) ‚Üí Path (green) ‚Üí End (magenta)
                    </div>
                    
                    <div class="preset-container">
                        <button class="preset-btn" onclick="loadPreset('snake')">üêç Snake</button>
                        <button class="preset-btn" onclick="loadPreset('spiral')">üåÄ Spiral</button>
                        <button class="preset-btn" onclick="loadPreset('zigzag')">‚ö° ZigZag</button>
                        <button class="preset-btn" onclick="loadPreset('maze')">üèõÔ∏è Maze</button>
                        <button class="preset-btn" onclick="loadPreset('straight')">‚û°Ô∏è Straight</button>
                        <button class="preset-btn" onclick="clearPath()">üóëÔ∏è Clear</button>
                    </div>
                    
                    <div class="path-grid" id="path-grid"></div>
                    
                    <div style="color:#888; font-size:11px; margin-top:10px;">
                        Path Length: <span id="path-length" style="color:#0f0;">0</span> tiles
                    </div>
                </div>
            </div>
        </div>

        <div style="margin-top: 20px;">
            <button class="btn-main" onclick="startSandboxGame()">üöÄ START SANDBOX</button>
            <button class="btn-main" onclick="closeSandbox()">BACK</button>
        </div>
    </div>

    <div id="game-over-screen" class="overlay-screen" style="display:none;">
        <h1 style="color:red; -webkit-text-fill-color: red;">AI TAKEOVER COMPLETE</h1>
        <h2 id="final-score">The Neuro-Core has been compromised</h2>
        <button class="btn-main" onclick="restartLevel()">RESTART</button>
        <button class="btn-main" onclick="showMenu()">MAIN MENU</button>
    </div>

    <div id="victory-screen" class="overlay-screen" style="display:none;">
        <h1 style="color:#0f0; -webkit-text-fill-color: #0f0;">CORE SECURED</h1>
        <h2 id="victory-msg">Next Level Unlocked</h2>
        <button class="btn-main" onclick="restartLevel()">RESTART</button>
        <button class="btn-main" onclick="showMenu()">MAIN MENU</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // AUDIO ENGINE
        class SfxEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.initialized = false;
                this.enabled = true;
                this.masterVolume = 0.3;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = this.masterVolume;
                    this.masterGain.connect(this.ctx.destination);
                    this.initialized = true;
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                } catch(e) {}
            }

            playSonicWave() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.5);
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(8, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(20, now);
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    osc.connect(gainNode);
                    gainNode.gain.setValueAtTime(0.25, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.5);
                    lfo.stop(now + 0.5);
                } catch(e) {}
            }

            playTremoloWave() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, now);
                    osc.connect(gainNode);
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(15, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(0.15, now);
                    lfo.connect(lfoGain);
                    lfoGain.connect(gainNode.gain);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.6);
                    lfo.stop(now + 0.6);
                } catch(e) {}
            }

            playUnderwaterEcho() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(120, now);
                    osc.frequency.linearRampToValueAtTime(90, now + 0.6);
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(800, now);
                    filter.Q.setValueAtTime(5, now);
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(4, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(200, now);
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                    osc.connect(filter);
                    filter.connect(gainNode);
                    gainNode.gain.setValueAtTime(0.25, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.6);
                    lfo.stop(now + 0.6);
                } catch(e) {}
            }

            playBuild() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(60, now);
                    osc.frequency.linearRampToValueAtTime(30, now + 0.4);
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(3, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(15, now);
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    osc.connect(gainNode);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.4);
                    lfo.stop(now + 0.4);
                } catch(e) {}
            }

            playUpgrade() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.exponentialRampToValueAtTime(300, now + 0.7);
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(6, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(25, now);
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    osc.connect(gainNode);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.linearRampToValueAtTime(0.3, now + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.7);
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.7);
                    lfo.stop(now + 0.7);
                } catch(e) {}
            }

            playError() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(80, now);
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, now);
                    filter.Q.setValueAtTime(10, now);
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(6, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(800, now);
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                    osc.connect(filter);
                    filter.connect(gainNode);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.4);
                    lfo.stop(now + 0.4);
                } catch(e) {}
            }

            playResonantRing() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(200, now + 0.5);
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(400, now);
                    filter.Q.setValueAtTime(20, now);
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(7, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(100, now);
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                    osc.connect(filter);
                    filter.connect(gainNode);
                    gainNode.gain.setValueAtTime(0.25, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 0.5);
                    lfo.stop(now + 0.5);
                } catch(e) {}
            }

            playCoreHit() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc1 = this.ctx.createOscillator();
                    const osc2 = this.ctx.createOscillator();
                    osc1.type = 'sine';
                    osc2.type = 'sine';
                    osc1.frequency.setValueAtTime(150, now);
                    osc2.frequency.setValueAtTime(150.5, now);
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(0.5, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(5, now);
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc2.frequency);
                    osc1.connect(gainNode);
                    osc2.connect(gainNode);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    osc1.start(now);
                    osc2.start(now);
                    lfo.start(now);
                    osc1.stop(now + 0.6);
                    osc2.stop(now + 0.6);
                    lfo.stop(now + 0.6);
                } catch(e) {}
            }

            playCoreDestroy() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 1.5);
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(400, now);
                    filter.Q.setValueAtTime(20, now);
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.setValueAtTime(7, now);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.setValueAtTime(100, now);
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                    osc.connect(filter);
                    filter.connect(gainNode);
                    gainNode.gain.setValueAtTime(0.4, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
                    osc.start(now);
                    lfo.start(now);
                    osc.stop(now + 1.5);
                    lfo.stop(now + 1.5);
                } catch(e) {}
            }

            playPhase() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc1 = this.ctx.createOscillator();
                    const osc2 = this.ctx.createOscillator();
                    osc1.type = 'sine';
                    osc2.type = 'sine';
                    osc1.frequency.setValueAtTime(200, now);
                    osc2.frequency.setValueAtTime(200.8, now);
                    osc1.connect(gainNode);
                    osc2.connect(gainNode);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc1.start(now);
                    osc2.start(now);
                    osc1.stop(now + 0.3);
                    osc2.stop(now + 0.3);
                } catch(e) {}
            }

            playHeal() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const fundamentalFreq = 200;
                    const harmonics = [1, 1.5, 2];
                    harmonics.forEach((harmonic, i) => {
                        const osc = this.ctx.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(fundamentalFreq * harmonic, now);
                        const oscGain = this.ctx.createGain();
                        oscGain.gain.setValueAtTime(0.3 / harmonic, now);
                        osc.connect(oscGain);
                        oscGain.connect(gainNode);
                        osc.start(now);
                        osc.stop(now + 0.5);
                    });
                    gainNode.gain.setValueAtTime(0.25, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                } catch(e) {}
            }

            playCollapse() {
                if (!this.ctx || !this.initialized || !this.enabled) return;
                try {
                    const now = this.ctx.currentTime;
                    const gainNode = this.ctx.createGain();
                    gainNode.connect(this.masterGain);
                    const osc = this.ctx.createOscillator();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(40, now + 1.0);
                    osc.connect(gainNode);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                    osc.start(now);
                    osc.stop(now + 1.0);
                } catch(e) {}
            }
        }
        
        const sfx = new SfxEngine();

        window.toggleSound = function() {
            sfx.enabled = !sfx.enabled;
            const btn = document.getElementById('sound-toggle');
            if (sfx.enabled) {
                btn.classList.add('active');
                btn.innerText = 'üîä SOUND: ON';
            } else {
                btn.classList.remove('active');
                btn.innerText = 'üîá SOUND: OFF';
            }
        }

        function createCharTexture(char, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 48px Courier New';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(char, 32, 32);
            const tex = new THREE.CanvasTexture(canvas);
            tex.needsUpdate = true;
            return tex;
        }

        let texZero, texOne, texHex;
        const TILE_SIZE = 4;
        let scene, camera, renderer, controls, raycaster, mouse;
        let ambientLight, directionalLight;
        let isPaused = false;
        let deleteMode = false;
        let selectedTower = null;
        let selectedTile = null;
        let neuroCore = null;
        let portalGateway = null;
        let gameSpeed = 1.0;
        let matrixSkyDome = null;
        
        let gameState = {
            money: 400,
            lives: 20,
            wave: 1,
            levelIndex: 0,
            selectedTowerType: 0,
            isGameOver: false,
            collapsedTiles: [],
            sandboxConfig: {
                customPath: [],
                enemyCount: 5,
                enemyMix: { normal: 0.7, speed: 0.2, tank: 0.1 },
                difficultyScale: 1.0,
                bossInterval: 5,
                startingMoney: 450,
                color: new THREE.Color(0.0, 1.0, 0.5),
                towerRestrictions: [true, true, true],
                maxWaves: null
            }
        };

        let sandboxPath = [];
        let pathGrid = [];

        window.loadPreset = function(presetName) {
            const presets = {
                snake: [{x:-8,z:-8}, {x:-8,z:-2}, {x:0,z:-2}, {x:0,z:2}, {x:8,z:2}, {x:8,z:8}],
                spiral: [{x:-10,z:-10}, {x:10,z:-10}, {x:10,z:10}, {x:-5,z:10}, {x:-5,z:-5}, {x:5,z:-5}, {x:5,z:5}, {x:0,z:5}],
                zigzag: [{x:-8,z:8}, {x:-4,z:8}, {x:-4,z:-8}, {x:0,z:-8}, {x:0,z:8}, {x:4,z:8}, {x:4,z:-8}, {x:8,z:-8}, {x:8,z:8}],
                maze: [{x:-10,z:-8}, {x:-2,z:-8}, {x:-2,z:0}, {x:8,z:0}, {x:8,z:8}],
                straight: [{x:-10,z:0}, {x:10,z:0}]
            };
            sandboxPath = presets[presetName] || [];
            renderPathGrid();
        }

        window.clearPath = function() {
            sandboxPath = [];
            renderPathGrid();
        }

        function initPathGrid() {
            const grid = document.getElementById('path-grid');
            grid.innerHTML = '';
            pathGrid = [];
            
            for (let z = 8; z >= -8; z--) {
                for (let x = -8; x <= 8; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'path-cell';
                    cell.dataset.x = x;
                    cell.dataset.z = z;
                    cell.onclick = function() {
                        const cx = parseInt(this.dataset.x);
                        const cz = parseInt(this.dataset.z);
                        togglePathCell(cx, cz);
                    };
                    grid.appendChild(cell);
                    pathGrid.push({x, z, element: cell});
                }
            }
            renderPathGrid();
        }

        function togglePathCell(x, z) {
            const index = sandboxPath.findIndex(p => p.x === x && p.z === z);
            if (index === -1) {
                sandboxPath.push({x, z});
            } else {
                sandboxPath.splice(index, 1);
            }
            renderPathGrid();
        }

        function renderPathGrid() {
            pathGrid.forEach(cell => {
                const hasPath = sandboxPath.some(p => p.x === cell.x && p.z === cell.z);
                const isStart = sandboxPath.length > 0 && sandboxPath[0].x === cell.x && sandboxPath[0].z === cell.z;
                const isEnd = sandboxPath.length > 0 && sandboxPath[sandboxPath.length - 1].x === cell.x && sandboxPath[sandboxPath.length - 1].z === cell.z;
                
                cell.element.className = 'path-cell';
                if (isStart) cell.element.classList.add('start');
                else if (isEnd) cell.element.classList.add('end');
                else if (hasPath) cell.element.classList.add('path');
            });
            document.getElementById('path-length').innerText = sandboxPath.length;
        }

        window.openSandbox = function() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('sandbox-setup-screen').style.display = 'flex';
            initPathGrid();
            updateSandboxUI();
        }

        window.closeSandbox = function() {
            document.getElementById('sandbox-setup-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
        }

        function updateSandboxUI() {
            document.getElementById('sandbox-difficulty').oninput = function() {
                const val = (this.value / 100).toFixed(1);
                document.getElementById('sandbox-difficulty-val').innerText = val + 'x';
            };
            document.getElementById('sandbox-normal').oninput = function() {
                document.getElementById('sandbox-normal-val').innerText = this.value + '%';
            };
            document.getElementById('sandbox-speed').oninput = function() {
                document.getElementById('sandbox-speed-val').innerText = this.value + '%';
            };
            document.getElementById('sandbox-tank').oninput = function() {
                document.getElementById('sandbox-tank-val').innerText = this.value + '%';
            };
            document.getElementById('sandbox-hue').oninput = function() {
                const hue = this.value;
                document.getElementById('sandbox-color-preview').style.background = `hsl(${hue}, 100%, 50%)`;
            };
            document.getElementById('sandbox-color-preview').style.background = 'hsl(120, 100%, 50%)';
        }

        window.startSandboxGame = function() {
            if (sandboxPath.length < 2) {
                alert('Path needs at least 2 points (start and end)!');
                return;
            }
            gameState.sandboxConfig = {
                startingMoney: parseInt(document.getElementById('sandbox-money').value),
                difficultyScale: parseFloat(document.getElementById('sandbox-difficulty').value) / 100,
                enemyCount: parseInt(document.getElementById('sandbox-enemy-count').value),
                bossInterval: parseInt(document.getElementById('sandbox-boss-interval').value),
                maxWaves: parseInt(document.getElementById('sandbox-max-waves').value) || null,
                enemyMix: {
                    normal: parseFloat(document.getElementById('sandbox-normal').value) / 100,
                    speed: parseFloat(document.getElementById('sandbox-speed').value) / 100,
                    tank: parseFloat(document.getElementById('sandbox-tank').value) / 100
                },
                hue: parseInt(document.getElementById('sandbox-hue').value),
                color: new THREE.Color().setHSL(
                    parseInt(document.getElementById('sandbox-hue').value) / 360, 1.0, 0.5
                ),
                customPath: JSON.parse(JSON.stringify(sandboxPath)),
                towerRestrictions: [true, true, true]
            };
            startGame(4);
        }

        const TOWER_TYPES = [
            { 
                name: "HACKER-0", baseCost: 50, 
                upgrades: [
                    { damage: 10, range: 15, rate: 0.6, color: 0x00ffff, cost: 0 },
                    { damage: 20, range: 18, rate: 0.5, color: 0x00ddff, cost: 80 },
                    { damage: 35, range: 20, rate: 0.4, color: 0x0088ff, cost: 150 }
                ],
                projectileSpeed: 40
            },
            { 
                name: "HACKER-1", baseCost: 120,
                upgrades: [
                    { damage: 50, range: 30, rate: 2.0, color: 0xffff00, cost: 0 },
                    { damage: 100, range: 40, rate: 1.5, color: 0xffcc00, cost: 200 },
                    { damage: 200, range: 50, rate: 1.2, color: 0xff8800, cost: 350 }
                ],
                projectileSpeed: 80
            },
            { 
                name: "HACKER-X", baseCost: 200,
                upgrades: [
                    { damage: 20, range: 12, rate: 1.5, color: 0xff00ff, cost: 0, aoe: 8 },
                    { damage: 40, range: 15, rate: 1.2, color: 0xff00cc, cost: 250 },
                    { damage: 70, range: 18, rate: 1.0, color: 0xff0088, cost: 400, aoe: 12 }
                ],
                projectileSpeed: 25
            }
        ];

        const LEVELS = [
            { color: new THREE.Color(0.0, 1.0, 1.0), path: [{x:-8,z:-8}, {x:-8,z:-2}, {x:0,z:-2}, {x:0,z:2}, {x:8,z:2}, {x:8,z:8}] },
            { color: new THREE.Color(1.0, 0.0, 1.0), path: [{x:-10,z:-10}, {x:10,z:-10}, {x:10,z:10}, {x:-5,z:10}, {x:-5,z:-5}, {x:5,z:-5}, {x:5,z:5}, {x:0,z:5}] },
            { color: new THREE.Color(1.0, 1.0, 0.0), path: [{x:-8,z:8}, {x:-4,z:8}, {x:-4,z:-8}, {x:0,z:-8}, {x:0,z:8}, {x:4,z:8}, {x:4,z:-8}, {x:8,z:-8}, {x:8,z:8}] },
            { color: new THREE.Color(1.0, 0.5, 0.0), path: [{x:-10,z:-8}, {x:-2,z:-8}, {x:-2,z:0}, {x:8,z:0}, {x:8,z:8}], isBalloonLevel: true },
            { isSandbox: true, color: new THREE.Color(0.0, 1.0, 0.5), path: [] }
        ];

        const entities = {
            towers: [],
            enemies: [],
            projectiles: [],
            particles: [],
            tiles: []
        };

        const shake = { amount: 0 };

        const bgUniforms = {
            uTime: { value: 0 },
            uColor: { value: new THREE.Vector3(0,1,1) }
        };
        
        const bgMaterial = new THREE.ShaderMaterial({
            uniforms: bgUniforms,
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec2 vUv;
                void main() {
                    vec2 grid = abs(fract(vUv * 20.0 - vec2(0, uTime * 0.2)) - 0.5) / fwidth(vUv * 20.0);
                    float line = min(grid.x, grid.y);
                    float alpha = 1.0 - min(line, 1.0);
                    float dist = distance(vUv, vec2(0.5, 0.5));
                    alpha *= (1.0 - dist * 1.5);
                    vec3 finalColor = uColor * alpha * 2.0;
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        function createMatrixSkyDome() {
            const skyGeo = new THREE.SphereGeometry(100, 64, 64);
            const skyUniforms = { uTime: { value: 0 } };
            
            const vertexShader = `
                varying vec3 vPosition;
                varying vec2 vUv;
                void main() {
                    vPosition = position;
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            
            const fragmentShader = `
                precision highp float;
                varying vec3 vPosition;
                varying vec2 vUv;
                uniform float uTime;

                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }

                float matrixRain(vec2 uv, float time) {
                    float col = floor(uv.x * 40.0);
                    float speed = hash(vec2(col, 0.0)) * 1.5 + 0.5;
                    float y = fract(uv.y * 12.0 - time * speed);
                    float bright = smoothstep(0.08, 0.0, y) * smoothstep(0.0, 0.15, y);
                    float charRandom = hash(vec2(col, floor(uv.y * 12.0 - time * speed)));
                    return charRandom > 0.7 ? bright : 0.0;
                }

                vec2 voronoiHash(vec2 p) {
                    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
                    return fract(sin(p) * 43758.5453);
                }

                float voronoi(vec2 uv, float time) {
                    vec2 i = floor(uv);
                    vec2 f = fract(uv);
                    float minDist = 1.0;
                    for(int y = -1; y <= 1; y++) {
                        for(int x = -1; x <= 1; x++) {
                            vec2 neighbor = vec2(float(x), float(y));
                            vec2 point = voronoiHash(i + neighbor);
                            point = 0.5 + 0.5 * sin(time * 0.3 + 6.28 * point);
                            minDist = min(minDist, length(neighbor + point - f));
                        }
                    }
                    return minDist;
                }

                void main() {
                    vec3 pos = normalize(vPosition);
                    float theta = atan(pos.z, pos.x);
                    float phi = acos(pos.y);
                    vec2 uv = vec2(theta / 6.28318, phi / 3.14159);
                    
                    vec3 baseColor = vec3(0.0, 0.01, 0.03);
                    float depthGradient = pow(uv.y, 2.0);
                    baseColor += vec3(0.0, 0.02, 0.05) * (1.0 - depthGradient);
                    
                    float rain = matrixRain(uv, uTime * 0.2);
                    rain += matrixRain(uv * 1.3 + 0.2, uTime * 0.3) * 0.4;
                    vec3 rainColor = vec3(0.0, 0.3, 0.1) * rain;
                    
                    float cells = voronoi(uv * 8.0, uTime * 0.15);
                    cells = pow(1.0 - cells, 3.0);
                    vec3 cellColor = vec3(0.0, 0.1, 0.15) * cells * 0.15;
                    
                    float ringAngle = theta + uTime * 0.3;
                    float rings = (sin(phi * 30.0 + ringAngle * 3.0) * 0.5 + 0.5);
                    rings = pow(rings, 15.0);
                    vec3 ringColor = vec3(0.15, 0.0, 0.2) * rings;
                    
                    vec2 starUV = uv * 25.0;
                    vec2 starId = floor(starUV);
                    float starHash = hash(starId);
                    float star = 0.0;
                    if(starHash > 0.95 && uv.y > 0.4) {
                        vec2 starPos = fract(starUV) - 0.5;
                        star = smoothstep(0.03, 0.0, length(starPos));
                        star *= (sin(uTime * 1.5 + starHash * 6.28) * 0.4 + 0.6);
                    }
                    vec3 starColor = vec3(0.4, 0.4, 0.5) * star;
                    
                    float horizon = smoothstep(0.53, 0.47, uv.y) * smoothstep(0.35, 0.47, uv.y);
                    vec3 horizonColor = vec3(0.0, 0.15, 0.2) * horizon * 0.3;
                    
                    float pulse = (sin(uTime * 0.5) * 0.5 + 0.5);
                    pulse = pow(pulse, 4.0);
                    vec3 pulseColor = vec3(0.05, 0.0, 0.1) * pulse * 0.2;
                    
                    vec3 finalColor = baseColor + rainColor + cellColor + ringColor + starColor + horizonColor + pulseColor;
                    finalColor *= (0.95 + sin(uTime * 0.8) * 0.05);
                    float vignette = 1.0 - length(vec2(uv.x - 0.5, uv.y - 0.5) * 0.5) * 0.3;
                    finalColor *= vignette;
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;
            
            const skyMat = new THREE.ShaderMaterial({
                uniforms: skyUniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide,
                fog: false,
                depthWrite: false,
                depthTest: false
            });
            
            const skyMesh = new THREE.Mesh(skyGeo, skyMat);
            skyMesh.position.set(0, 0, 0);
            skyMesh.renderOrder = -100;
            skyMesh.userData.uniforms = skyUniforms;
            return skyMesh;
        }

        // === SCHRITT 1: NEBEL WOLKEN & GLITZER PARTIKEL ===
        let fogClouds = [];
        let glitterParticles = [];

        function createFogClouds() {
            console.log('‚òÅÔ∏è Creating Fog Clouds...');
            const cloudGroup = new THREE.Group();

            for (let i = 0; i < 8; i++) {
                const cloudGeo = new THREE.SphereGeometry(8 + Math.random() * 5, 16, 16);

                const cloudMat = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uOpacity: { value: 0.15 + Math.random() * 0.1 },
                        uColor: { value: new THREE.Color(0.0, 0.3 + Math.random() * 0.2, 0.5 + Math.random() * 0.3) }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vPosition = position;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float uTime;
                        uniform float uOpacity;
                        uniform vec3 uColor;
                        varying vec3 vNormal;
                        varying vec3 vPosition;

                        float noise(vec3 p) {
                            return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
                        }

                        void main() {
                            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 2.0);
                            float n = noise(vPosition * 0.3 + vec3(uTime * 0.1));
                            n = n * 0.5 + 0.5;
                            vec3 color = uColor * (0.8 + n * 0.4);
                            float alpha = uOpacity * fresnel * n;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });

                const cloud = new THREE.Mesh(cloudGeo, cloudMat);

                const angle = Math.random() * Math.PI * 2;
                const radius = 30 + Math.random() * 20;
                const height = -5 + Math.random() * 20;

                cloud.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );

                cloud.userData = {
                    speed: 0.3 + Math.random() * 0.5,
                    angle: angle,
                    radius: radius,
                    heightOffset: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2
                };

                cloudGroup.add(cloud);
                fogClouds.push(cloud);
            }

            console.log('‚úÖ Created', fogClouds.length, 'fog clouds');
            return cloudGroup;
        }

        function updateFogClouds(dt, time) {
            fogClouds.forEach(cloud => {
                cloud.userData.angle += cloud.userData.speed * dt * 0.1;
                cloud.position.x = Math.cos(cloud.userData.angle) * cloud.userData.radius;
                cloud.position.z = Math.sin(cloud.userData.angle) * cloud.userData.radius;
                cloud.position.y += Math.sin(time * 0.5 + cloud.userData.heightOffset) * 0.02;
                cloud.rotation.y += cloud.userData.rotationSpeed * dt;
                cloud.material.uniforms.uTime.value = time;
            });
        }

        function createGlitterParticles() {
            console.log('‚ú® Creating Glitter Particles...');
            const particleGroup = new THREE.Group();

            for (let i = 0; i < 100; i++) {
                const particleGeo = new THREE.SphereGeometry(0.1 + Math.random() * 0.15, 8, 8);

                const color = new THREE.Color();
                const hue = Math.random();
                if (hue < 0.3) {
                    color.setHex(0x00ffff);
                } else if (hue < 0.6) {
                    color.setHex(0xff00ff);
                } else {
                    color.setHex(0xffff00);
                }

                const particleMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });

                const particle = new THREE.Mesh(particleGeo, particleMat);

                particle.position.set(
                    (Math.random() - 0.5) * 60,
                    Math.random() * 25,
                    (Math.random() - 0.5) * 60
                );

                particle.userData = {
                    baseY: particle.position.y,
                    floatSpeed: 0.5 + Math.random() * 1.0,
                    floatOffset: Math.random() * Math.PI * 2,
                    twinkleSpeed: 2.0 + Math.random() * 3.0,
                    twinkleOffset: Math.random() * Math.PI * 2,
                    driftX: (Math.random() - 0.5) * 0.5,
                    driftZ: (Math.random() - 0.5) * 0.5,
                    baseOpacity: 0.4 + Math.random() * 0.4
                };

                particleGroup.add(particle);
                glitterParticles.push(particle);
            }

            console.log('‚úÖ Created', glitterParticles.length, 'glitter particles');
            return particleGroup;
        }

        function updateGlitterParticles(dt, time) {
            glitterParticles.forEach(p => {
                p.position.y = p.userData.baseY + Math.sin(time * p.userData.floatSpeed + p.userData.floatOffset) * 2;
                p.position.x += p.userData.driftX * dt;
                p.position.z += p.userData.driftZ * dt;

                if (p.position.x > 35) p.position.x = -35;
                if (p.position.x < -35) p.position.x = 35;
                if (p.position.z > 35) p.position.z = -35;
                if (p.position.z < -35) p.position.z = 35;

                const twinkle = Math.sin(time * p.userData.twinkleSpeed + p.userData.twinkleOffset) * 0.5 + 0.5;
                p.material.opacity = p.userData.baseOpacity * twinkle;

                p.rotation.x += dt * 0.5;
                p.rotation.y += dt * 0.7;
            });
        }

        let fogCloudGroup = null;
        let glitterGroup = null;
        // === END FOG & GLITTER ===

        class PortalGateway {
            constructor(x, z) {
                this.group = new THREE.Group();
                const ringGeo = new THREE.TorusGeometry(3, 0.4, 20, 50);
                const ringMat = new THREE.MeshStandardMaterial({
                    color: 0x222222, roughness: 0.4, metalness: 0.9,
                    emissive: 0x001133, emissiveIntensity: 0.3
                });
                this.ringMesh = new THREE.Mesh(ringGeo, ringMat);
                this.ringMesh.rotation.x = Math.PI / 2;
                this.group.add(this.ringMesh);

                const outerGlowGeo = new THREE.TorusGeometry(3.5, 0.08, 12, 50);
                const outerGlowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                this.outerGlow = new THREE.Mesh(outerGlowGeo, outerGlowMat);
                this.outerGlow.rotation.x = Math.PI / 2;
                this.group.add(this.outerGlow);

                const horizonVertShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
                const horizonFragShader = `
                    uniform float uTime; varying vec2 vUv;
                    void main() {
                        vec2 centeredUv = vUv - 0.5;
                        float dist = length(centeredUv);
                        float wave1 = sin(dist * 20.0 - uTime * 3.0);
                        float wave2 = sin(dist * 35.0 - uTime * 5.0 + 1.0);
                        float combinedWave = (wave1 + wave2) * 0.5;
                        vec3 colorDeep = vec3(0.0, 0.1, 0.4);
                        vec3 colorBright = vec3(0.0, 1.0, 0.8);
                        vec3 colorHot = vec3(0.6, 0.0, 1.0);
                        vec3 finalColor = mix(colorDeep, colorBright, combinedWave + 0.5);
                        finalColor += mix(colorHot, vec3(0.0), dist * 2.5);
                        float edgeMask = 1.0 - smoothstep(0.38, 0.48, dist);
                        gl_FragColor = vec4(finalColor, edgeMask * 0.9);
                    }
                `;

                this.horizonUniforms = { uTime: { value: 0 } };
                const horizonGeo = new THREE.CircleGeometry(3.2, 64);
                const horizonMat = new THREE.ShaderMaterial({
                    uniforms: this.horizonUniforms,
                    vertexShader: horizonVertShader,
                    fragmentShader: horizonFragShader,
                    transparent: true, side: THREE.DoubleSide
                });
                this.eventHorizon = new THREE.Mesh(horizonGeo, horizonMat);
                this.eventHorizon.rotation.x = Math.PI / 2;
                this.eventHorizon.position.y = 0.1;
                this.group.add(this.eventHorizon);

                const lightningGeo = new THREE.BufferGeometry();
                const lightningCount = 80;
                const lPos = new Float32Array(lightningCount * 3);
                lightningGeo.setAttribute('position', new THREE.BufferAttribute(lPos, 3));
                const lightningMat = new THREE.LineBasicMaterial({
                    color: 0xffffff, opacity: 0.8, transparent: true, blending: THREE.AdditiveBlending
                });
                this.lightning = new THREE.LineSegments(lightningGeo, lightningMat);
                this.group.add(this.lightning);

                this.light = new THREE.PointLight(0x00ffff, 2, 20);
                this.light.position.set(0, 2, 0);
                this.group.add(this.light);

                this.group.position.set(x * TILE_SIZE, 1.5, z * TILE_SIZE);
                this.animTime = 0;
                scene.add(this.group);
            }

            update(dt) {
                this.animTime += dt;
                this.horizonUniforms.uTime.value = this.animTime;
                this.outerGlow.rotation.z = this.animTime * 0.5;
                
                const positions = this.lightning.geometry.attributes.position.array;
                for (let i = 0; i < 80; i += 2) {
                    const radiusBase = 3.3;
                    const angle1 = Math.random() * Math.PI * 2;
                    const angle2 = angle1 + (Math.random() - 0.5) * 0.5;
                    positions[i * 3] = Math.cos(angle1) * radiusBase + (Math.random() - 0.5);
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 2] = Math.sin(angle1) * radiusBase + (Math.random() - 0.5);
                    positions[i * 3 + 3] = Math.cos(angle2) * radiusBase + (Math.random() - 0.5);
                    positions[i * 3 + 4] = (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 5] = Math.sin(angle2) * radiusBase + (Math.random() - 0.5);
                }
                this.lightning.geometry.attributes.position.needsUpdate = true;
                this.lightning.material.opacity = 0.3 + Math.random() * 0.7;
                this.group.position.y = 1.5 + Math.sin(this.animTime * 0.5) * 0.2;
            }
        }

        class NeuroCore {
            constructor(x, z) {
                this.group = new THREE.Group();
                this.health = 20;
                this.maxHealth = 20;
                this.destroyed = false;
                
                const coreGeo = new THREE.IcosahedronGeometry(2, 1);
                const coreMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.8
                });
                this.coreMesh = new THREE.Mesh(coreGeo, coreMat);
                this.group.add(this.coreMesh);

                const innerCoreMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, transparent: true, opacity: 0.6
                });
                this.innerCore = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 0), innerCoreMat);
                this.group.add(this.innerCore);

                this.blocks = [];
                const blockGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const blockMat = new THREE.MeshStandardMaterial({
                    color: 0x111111, emissive: 0x00ffff, emissiveIntensity: 0.3,
                    metalness: 0.9, roughness: 0.1
                });

                for(let i = 0; i < 12; i++) {
                    const block = new THREE.Mesh(blockGeo, blockMat.clone());
                    const radius = 3 + Math.random() * 1;
                    const theta = (i / 12) * Math.PI * 2;
                    const phi = Math.PI / 4 + (Math.random() - 0.5) * 0.5;
                    block.position.setFromSphericalCoords(radius, phi, theta);
                    block.lookAt(0, 0, 0);
                    block.scale.set(1, 2 + Math.random() * 2, 1);
                    this.group.add(block);
                    this.blocks.push({ mesh: block, originalPos: block.position.clone(), offset: i * 0.5 });
                }

                this.cables = [];
                for(let i = 0; i < 6; i++) {
                    const cableGeo = new THREE.CylinderGeometry(0.1, 0.1, 3, 6);
                    const cableMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
                    const cable = new THREE.Mesh(cableGeo, cableMat);
                    const angle = (i / 6) * Math.PI * 2;
                    cable.position.set(Math.cos(angle) * 2, -2, Math.sin(angle) * 2);
                    cable.rotation.x = Math.PI / 6;
                    this.group.add(cable);
                    this.cables.push(cable);
                }

                this.light = new THREE.PointLight(0x00ffff, 2, 15);
                this.light.position.set(0, 2, 0);
                this.group.add(this.light);

                this.group.position.set(x * TILE_SIZE, 2, z * TILE_SIZE);
                this.animTime = 0;
                this.flashTime = 0;
                scene.add(this.group);
            }

            takeDamage() {
                if (this.destroyed) return;
                this.health--;
                this.flashTime = 0.3;
                sfx.playCoreHit();
                shake.amount = 0.8;

                const healthPct = this.health / this.maxHealth;
                const color = new THREE.Color().setHSL(healthPct * 0.5, 1, 0.5);
                this.coreMesh.material.color = color;
                this.light.color = color;
                this.blocks.forEach(b => { b.mesh.material.emissive = color; });

                if (this.health <= 0) this.destroy();
            }

            destroy() {
                this.destroyed = true;
                sfx.playCoreDestroy();
                shake.amount = 2;

                const growAnim = () => {
                    if (this.group.scale.x < 3) {
                        this.group.scale.multiplyScalar(1.02);
                        requestAnimationFrame(growAnim);
                    } else { endGame(); }
                };
                growAnim();

                this.coreMesh.material.color.setHex(0xff0000);
                this.innerCore.material.color.setHex(0xff0000);
                this.light.color.setHex(0xff0000);
                this.light.intensity = 5;
                this.blocks.forEach(b => {
                    b.mesh.material.emissive.setHex(0xff0000);
                    b.mesh.material.emissiveIntensity = 1;
                });
            }

            update(dt) {
                if (this.destroyed) { this.group.rotation.y += dt * 2; return; }
                this.animTime += dt;
                const pulse = 1 + Math.sin(this.animTime * 3) * 0.1;
                this.coreMesh.scale.setScalar(pulse);
                this.innerCore.scale.setScalar(pulse * 0.8);
                this.coreMesh.rotation.y += dt * 0.5;
                this.coreMesh.rotation.z += dt * 0.3;
                this.innerCore.rotation.y -= dt * 0.7;

                this.blocks.forEach(block => {
                    block.mesh.position.y = block.originalPos.y + Math.sin(this.animTime * 2 + block.offset) * 0.3;
                    block.mesh.rotation.y += dt * 0.5;
                });

                if (this.flashTime > 0) {
                    this.flashTime -= dt;
                    const flash = Math.sin(this.flashTime * 30) * 0.5 + 0.5;
                    this.coreMesh.material.opacity = 0.5 + flash * 0.5;
                    this.innerCore.material.opacity = 0.3 + flash * 0.7;
                    this.light.intensity = 2 + flash * 3;
                } else {
                    this.coreMesh.material.opacity = 0.8;
                    this.innerCore.material.opacity = 0.6;
                    this.light.intensity = 2;
                }
            }
        }

        function createCharacter(type, scale, color, eyeColor) {
            const charGroup = new THREE.Group();
            const armorMat = new THREE.MeshStandardMaterial({ 
                color: color, metalness: 0.9, roughness: 0.1,
                emissive: color, emissiveIntensity: 0.3
            });

            let torsoScale = 1, limbScale = 1, headScale = 1;
            if (type === 'SPEED') { torsoScale = 0.7; limbScale = 1.3; headScale = 0.8; }
            else if (type === 'TANK') { torsoScale = 1.5; limbScale = 0.8; headScale = 1.2; }
            else if (type === 'BOSS') { torsoScale = 2; limbScale = 1.5; headScale = 1.8; }
            else if (type === 'ASSASSIN') { torsoScale = 0.6; limbScale = 1.5; headScale = 0.7; }
            else if (type === 'JUGGERNAUT') { torsoScale = 2.5; limbScale = 1.0; headScale = 1.5; }
            else if (type === 'GHOST') { torsoScale = 0.9; limbScale = 1.1; headScale = 1.0; }
            else if (type === 'HEALER') { torsoScale = 1.1; limbScale = 1.0; headScale = 1.1; }
            else if (type === 'SPLITTER') { torsoScale = 0.8; limbScale = 0.9; headScale = 0.9; }
            else if (type === 'NATRON') { torsoScale = 1.3; limbScale = 1.2; headScale = 1.3; }

            const torso = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.35 * torsoScale * scale, 0.8 * scale, 8, 16), armorMat
            );
            torso.position.y = 0;
            torso.castShadow = true;
            charGroup.add(torso);

            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.25 * headScale * scale, 16, 16), armorMat
            );
            head.position.y = (0.4 + 0.25 * headScale) * scale;
            head.castShadow = true;
            torso.add(head);

            const eye = new THREE.Mesh(
                new THREE.BoxGeometry(0.35 * headScale * scale, 0.05 * scale, 0.1 * scale), 
                new THREE.MeshBasicMaterial({color: eyeColor})
            );
            eye.position.set(0, 0.05 * scale, 0.22 * headScale * scale);
            head.add(eye);

            const limbGeo = new THREE.CapsuleGeometry(0.12 * scale, 0.5 * limbScale * scale, 6, 6);
            const armL = new THREE.Mesh(limbGeo, armorMat);
            const armR = new THREE.Mesh(limbGeo, armorMat);
            armL.position.set(-0.5 * torsoScale * scale, 0, 0);
            armR.position.set(0.5 * torsoScale * scale, 0, 0);
            armL.castShadow = true;
            armR.castShadow = true;
            torso.add(armL, armR);

            const legL = new THREE.Mesh(limbGeo, armorMat);
            const legR = new THREE.Mesh(limbGeo, armorMat);
            legL.position.set(-0.2 * torsoScale * scale, (-0.4 - 0.25 * limbScale) * scale, 0);
            legR.position.set(0.2 * torsoScale * scale, (-0.4 - 0.25 * limbScale) * scale, 0);
            legL.castShadow = true;
            legR.castShadow = true;
            torso.add(legL, legR);

            charGroup.userData = { torso, head, armL, armR, legL, legR, type, scale, limbScale };
            return charGroup;
        }

        function collapseTileWithTower() {
            const towersOnTiles = entities.towers.filter(t => !t.isCollapsed);
            if (towersOnTiles.length === 0) return;

            const randomTower = towersOnTiles[Math.floor(Math.random() * towersOnTiles.length)];
            const tilePos = randomTower.mesh.position;
            
            const tile = entities.tiles.find(t => 
                Math.abs(t.position.x - tilePos.x) < 0.1 && 
                Math.abs(t.position.z - tilePos.z) < 0.1
            );

            if (tile && !tile.userData.collapsed) {
                collapseTile(tile, randomTower);
            }
        }

        function collapseTile(tile, tower) {
            tile.userData.collapsed = true;
            tile.userData.collapsedTower = tower;
            tower.isCollapsed = true;

            sfx.playCollapse();
            shake.amount = 1;

            const fallAnim = () => {
                if (tile.position.y > -10) {
                    tile.position.y -= 0.2;
                    tower.mesh.position.y -= 0.2;
                    requestAnimationFrame(fallAnim);
                } else {
                    tile.visible = false;
                    tower.mesh.visible = false;
                }
            };
            fallAnim();

            gameState.collapsedTiles.push({tile, tower});

            const msg = document.getElementById('msg-area');
            msg.innerText = "TILE COLLAPSED!";
            msg.style.opacity = 1;
            setTimeout(() => msg.style.opacity = 0, 2000);
        }

        window.repairTile = function() {
            if (!selectedTile || !selectedTile.userData.collapsed) return;
            
            const repairCost = 200;
            if (gameState.money < repairCost) {
                sfx.playError();
                return;
            }

            gameState.money -= repairCost;
            
            const collapsedData = gameState.collapsedTiles.find(c => c.tile === selectedTile);
            if (collapsedData) {
                selectedTile.userData.collapsed = false;
                selectedTile.userData.hasTower = false;
                selectedTile.userData.collapsedTower = null;
                selectedTile.visible = true;
                selectedTile.position.y = -0.5;
                selectedTile.material.color.setHex(0x444444);
                selectedTile.material.emissive.setHex(0x000000);
                selectedTile.material.emissiveIntensity = 0;

                const tower = collapsedData.tower;
                scene.remove(tower.mesh);
                const towerIndex = entities.towers.indexOf(tower);
                if (towerIndex > -1) entities.towers.splice(towerIndex, 1);

                const colIndex = gameState.collapsedTiles.indexOf(collapsedData);
                if (colIndex > -1) gameState.collapsedTiles.splice(colIndex, 1);

                sfx.playUpgrade();
                spawnParticles(selectedTile.position, 0x00ff00, 20);
            }

            hideTowerInfo();
            updateUI();
        }

        window.updateLighting = function(type, value) {
            value = parseFloat(value);
            if (type === 'ambient') {
                ambientLight.intensity = value / 100;
                document.getElementById('ambient-val').innerText = (value / 100).toFixed(2);
            } else if (type === 'directional') {
                directionalLight.intensity = value / 100;
                document.getElementById('dir-val').innerText = (value / 100).toFixed(2);
            } else if (type === 'hue') {
                const color = new THREE.Color().setHSL(value / 360, 1, 0.5);
                directionalLight.color = color;
                document.getElementById('hue-val').innerText = value + '¬∞';
            }
        }

        window.updateGameSpeed = function(value) {
            gameSpeed = value / 100;
            document.getElementById('speed-val').innerText = gameSpeed.toFixed(1) + 'x';
        }

        window.togglePause = function() {
            isPaused = !isPaused;
            document.getElementById('pause-overlay').style.display = isPaused ? 'flex' : 'none';
            const btn = document.querySelector('.control-btn.pause');
            if (btn) btn.innerText = isPaused ? '‚ñ∂Ô∏è RESUME' : '‚è∏Ô∏è PAUSE';
        }

        window.showMenu = function() {
            entities.towers.forEach(t => scene.remove(t.mesh));
            entities.enemies.forEach(e => scene.remove(e.mesh));
            entities.tiles.forEach(t => scene.remove(t));
            if (neuroCore) scene.remove(neuroCore.group);
            if (portalGateway) scene.remove(portalGateway.group);
            
            entities.towers = [];
            entities.enemies = [];
            entities.projectiles = [];
            entities.tiles = [];
            gameState.collapsedTiles = [];
            neuroCore = null;
            portalGateway = null;
            isPaused = false;
            gameState.isGameOver = true;
            
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('victory-screen').style.display = 'none';
            document.getElementById('build-menu').style.display = 'none';
            document.getElementById('game-controls').style.display = 'none';
            document.getElementById('light-panel').style.display = 'none';
            document.getElementById('tower-info-panel').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
            loadHighscores();
        }

        window.restartLevel = function() {
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('victory-screen').style.display = 'none';
            startGame(gameState.levelIndex);
        }

        window.toggleDeleteMode = function() {
            deleteMode = !deleteMode;
            const btn = document.querySelectorAll('.tower-btn')[3];
            
            if (deleteMode) {
                btn.classList.add('delete-mode');
                document.querySelectorAll('.tower-btn').forEach((b, i) => {
                    if (i < 3) b.classList.add('disabled');
                });
            } else {
                btn.classList.remove('delete-mode');
                applyTowerRestrictions();
            }
            hideTowerInfo();
        }

        function showTowerInfo(tower) {
            selectedTower = tower;
            selectedTile = null;
            const panel = document.getElementById('tower-info-panel');
            const typeData = TOWER_TYPES[tower.typeIndex];
            const currentUpgrade = typeData.upgrades[tower.level];
            
            document.getElementById('tower-info-name').innerText = typeData.name + ' HACKER';
            document.getElementById('tower-info-level').innerText = 'Level: ' + (tower.level + 1) + '/' + typeData.upgrades.length;
            document.getElementById('tower-info-damage').innerText = 'Damage: ' + currentUpgrade.damage;
            document.getElementById('tower-info-range').innerText = 'Range: ' + currentUpgrade.range;
            document.getElementById('tower-info-rate').innerText = 'Fire Rate: ' + currentUpgrade.rate + 's';
            
            const upgradeBtn = document.getElementById('upgrade-btn');
            if (tower.level < typeData.upgrades.length - 1) {
                const nextUpgrade = typeData.upgrades[tower.level + 1];
                upgradeBtn.innerText = `UPGRADE (${nextUpgrade.cost} CR)`;
                upgradeBtn.disabled = gameState.money < nextUpgrade.cost;
            } else {
                upgradeBtn.innerText = 'MAX LEVEL';
                upgradeBtn.disabled = true;
            }
            
            const sellValue = Math.floor(tower.getTotalCost() * 0.7);
            document.querySelector('.sell-btn').innerText = `SELL (${sellValue} CR)`;
            
            document.getElementById('repair-btn').style.display = 'none';
            panel.style.display = 'block';
        }

        function showTileInfo(tile) {
            selectedTile = tile;
            selectedTower = null;
            const panel = document.getElementById('tower-info-panel');
            
            document.getElementById('tower-info-name').innerText = 'COLLAPSED TILE';
            document.getElementById('tower-info-level').innerText = 'Status: Destroyed';
            document.getElementById('tower-info-damage').innerText = '';
            document.getElementById('tower-info-range').innerText = '';
            document.getElementById('tower-info-rate').innerText = '';
            
            document.getElementById('upgrade-btn').style.display = 'none';
            document.querySelector('.sell-btn').style.display = 'none';
            
            const repairBtn = document.getElementById('repair-btn');
            repairBtn.style.display = 'block';
            repairBtn.disabled = gameState.money < 200;
            
            panel.style.display = 'block';
        }

        function hideTowerInfo() {
            selectedTower = null;
            selectedTile = null;
            document.getElementById('tower-info-panel').style.display = 'none';
            document.getElementById('upgrade-btn').style.display = 'block';
            document.querySelector('.sell-btn').style.display = 'block';
            document.getElementById('repair-btn').style.display = 'none';
        }

        window.upgradeTower = function() {
            if (!selectedTower) return;
            const typeData = TOWER_TYPES[selectedTower.typeIndex];
            if (selectedTower.level >= typeData.upgrades.length - 1) return;
            const nextUpgrade = typeData.upgrades[selectedTower.level + 1];
            if (gameState.money >= nextUpgrade.cost) {
                gameState.money -= nextUpgrade.cost;
                selectedTower.upgrade();
                updateUI();
                showTowerInfo(selectedTower);
                sfx.playUpgrade();
            } else {
                sfx.playError();
            }
        }

        window.sellTower = function() {
            if (!selectedTower) return;
            const sellValue = Math.floor(selectedTower.getTotalCost() * 0.7);
            gameState.money += sellValue;
            
            const tilePos = selectedTower.mesh.position;
            const tile = entities.tiles.find(t => 
                Math.abs(t.position.x - tilePos.x) < 0.1 && 
                Math.abs(t.position.z - tilePos.z) < 0.1
            );
            if (tile) {
                tile.userData.hasTower = false;
                tile.material.color.setHex(0x444444);
            }
            
            scene.remove(selectedTower.mesh);
            const index = entities.towers.indexOf(selectedTower);
            if (index > -1) entities.towers.splice(index, 1);
            
            hideTowerInfo();
            updateUI();
            sfx.playError();
        }

        function saveHighscore() {
            const scores = JSON.parse(localStorage.getItem('highscores') || '[]');
            const levelName = gameState.levelIndex === 4 ? 'Sandbox' : `Level ${gameState.levelIndex + 1}`;
            scores.push({
                level: levelName,
                wave: gameState.wave - 1,
                date: new Date().toLocaleDateString()
            });
            scores.sort((a, b) => b.wave - a.wave);
            scores.splice(10);
            localStorage.setItem('highscores', JSON.stringify(scores));
        }

        function loadHighscores() {
            const scores = JSON.parse(localStorage.getItem('highscores') || '[]');
            const container = document.getElementById('highscore-list');
            container.innerHTML = '';
            if (scores.length === 0) {
                container.innerHTML = '<div style="color:#666; text-align:center; padding:20px;">No scores yet</div>';
                return;
            }
            scores.forEach((score, i) => {
                const entry = document.createElement('div');
                entry.className = 'highscore-entry';
                entry.innerHTML = `<span>${i + 1}. ${score.level}</span><span>Wave ${score.wave}</span>`;
                container.appendChild(entry);
            });
        }

        window.startGame = function(lvlIndex) {
            sfx.init();
            texZero = createCharTexture('0', '#00ff41');
            texOne = createCharTexture('1', '#00ff41');
            texHex = createCharTexture('‚¨°', '#00ffff');
            
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('sandbox-setup-screen').style.display = 'none';

            gameState.levelIndex = lvlIndex;
            gameState.wave = 1;
            gameState.isGameOver = false;
            gameState.collapsedTiles = [];
            isPaused = false;
            deleteMode = false;
            selectedTower = null;
            selectedTile = null;

            const level = LEVELS[lvlIndex];
            
            if (level.isSandbox) {
                gameState.money = gameState.sandboxConfig.startingMoney;
                gameState.lives = 20;
                level.color = gameState.sandboxConfig.color;
                level.path = gameState.sandboxConfig.customPath;
            } else {
                gameState.money = 450;
                gameState.lives = 20;
            }

            const levelColor = level.color;
            bgUniforms.uColor.value.set(levelColor.r, levelColor.g, levelColor.b);
            
            entities.towers.forEach(t => scene.remove(t.mesh));
            entities.enemies.forEach(e => scene.remove(e.mesh));
            entities.tiles.forEach(t => scene.remove(t));
            if (neuroCore) scene.remove(neuroCore.group);
            if (portalGateway) scene.remove(portalGateway.group);
            
            entities.towers = [];
            entities.enemies = [];
            entities.projectiles = [];
            entities.tiles = [];

            createGrid(level);
            
            const startPoint = level.path[0];
            portalGateway = new PortalGateway(startPoint.x, startPoint.z);
            
            const endPoint = level.path[level.path.length - 1];
            neuroCore = new NeuroCore(endPoint.x, endPoint.z);
            
            updateUI();
            applyTowerRestrictions();
            
            document.getElementById('build-menu').style.display = 'flex';
            document.getElementById('game-controls').style.display = 'flex';
            document.getElementById('light-panel').style.display = 'block';
            document.getElementById('tower-info-panel').style.display = 'none';
            
            startWave();
        }

        function applyTowerRestrictions() {
            document.querySelectorAll('.tower-btn').forEach((btn, i) => {
                if (i < 3) btn.classList.remove('disabled');
            });
        }

        window.selectTower = function(index) {
            gameState.selectedTowerType = index;
            document.querySelectorAll('.tower-btn').forEach((b, i) => {
                if (i < 3) b.classList.toggle('selected', i === index);
            });
            if (deleteMode) toggleDeleteMode();
            sfx.playBuild();
        }

        function createGrid(levelData) {
            const geo = new THREE.BoxGeometry(TILE_SIZE - 0.2, 1, TILE_SIZE - 0.2);
            const pathPoints = levelData.path;

            for (let x = -12; x <= 12; x++) {
                for (let z = -12; z <= 12; z++) {
                    const isPath = checkPath(x, z, pathPoints);
                    
                    const mat = new THREE.MeshStandardMaterial({
                        color: isPath ? 0x333333 : 0x444444,
                        emissive: isPath ? levelData.color.getHex() : 0x000000,
                        emissiveIntensity: isPath ? 0.3 : 0,
                        roughness: 0.3,
                        metalness: 0.7
                    });

                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(x * TILE_SIZE, -0.5, z * TILE_SIZE);
                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    
                    mesh.userData = { 
                        isPath, gridX: x, gridZ: z, hasTower: false,
                        collapsed: false, collapsedTower: null
                    };
                    
                    scene.add(mesh);
                    entities.tiles.push(mesh);
                }
            }
        }

        function checkPath(x, z, points) {
            for(let i=0; i<points.length-1; i++) {
                let p1 = points[i]; let p2 = points[i+1];
                if(p1.x === p2.x && x === p1.x && z >= Math.min(p1.z,p2.z) && z <= Math.max(p1.z,p2.z)) return true;
                if(p1.z === p2.z && z === p1.z && x >= Math.min(p1.x,p2.x) && x <= Math.max(p1.x,p2.x)) return true;
            }
            return false;
        }

        class Enemy {
            constructor(type, isBalloon = false, balloonSize = 3) {
                this.type = type;
                this.isBalloon = isBalloon;
                this.balloonSize = balloonSize;
                
                const cfg = LEVELS[gameState.levelIndex].isSandbox ? gameState.sandboxConfig : null;
                const scale = cfg ? cfg.difficultyScale : 1.0;
                
                let hp = (30 + gameState.wave * 15) * scale;
                let speed = 6;
                let charScale = 0.8;
                let color = 0xff0055;
                let eyeColor = 0xff0055;
                
                this.isPhasing = false;
                this.phaseTimer = 0;
                this.canHeal = false;
                this.healCooldown = 0;
                this.splits = 0;
                this.isNatron = false;
                this.damageByType = {};

                if (isBalloon) {
                    hp = 1;
                    speed = 4 + (4 - balloonSize) * 2;
                    charScale = 0.3 + balloonSize * 0.2;
                    const colors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00];
                    color = colors[balloonSize - 1] || 0xff0000;
                    eyeColor = 0xffffff;
                    const balloonGeo = new THREE.SphereGeometry(charScale, 16, 16);
                    const balloonMat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.5 });
                    this.mesh = new THREE.Mesh(balloonGeo, balloonMat);
                    this.mesh.castShadow = true;
                } else {
                    if (type === 'TANK') { hp *= 3; speed *= 0.6; charScale = 1.2; color = 0x00ff00; eyeColor = 0xff0000; }
                    if (type === 'SPEED') { hp *= 0.6; speed *= 1.4; charScale = 0.6; color = 0xffff00; eyeColor = 0xff8800; }
                    if (type === 'BOSS') { hp *= 10; speed *= 0.4; charScale = 1.8; color = 0xff00ff; eyeColor = 0x00ffff; }
                    if (type === 'ASSASSIN') { hp *= 0.4; speed *= 2.0; charScale = 0.7; color = 0x8800ff; eyeColor = 0xff00ff; this.reward = 30; }
                    if (type === 'JUGGERNAUT') { hp *= 6; speed *= 0.3; charScale = 1.6; color = 0x444444; eyeColor = 0xff0000; }
                    if (type === 'GHOST') { 
                        hp *= 1.5; speed *= 0.8; charScale = 0.9; color = 0x00ffaa; eyeColor = 0xffffff;
                        this.canPhase = true; this.phaseTimer = 3;
                    }
                    if (type === 'HEALER') { 
                        hp *= 2; speed *= 0.7; charScale = 1.0; color = 0x00ff88; eyeColor = 0xffff00;
                        this.canHeal = true; this.healCooldown = 0;
                    }
                    if (type === 'SPLITTER') { 
                        hp *= 1.5; speed *= 0.9; charScale = 0.9; color = 0xff8800; eyeColor = 0xffff00;
                        this.canSplit = true; this.splits = 0; this.maxSplits = 2;
                    }
                    if (type === 'NATRON') { 
                        hp *= 4; speed *= 0.7; charScale = 1.1; color = 0xffaa00; eyeColor = 0xff0000;
                        this.isNatron = true; this.reward = 50;
                    }
                    this.mesh = createCharacter(type, charScale, color, eyeColor);
                }
                
                const start = LEVELS[gameState.levelIndex].path[0];
                const yOffset = isBalloon ? charScale + 0.5 : charScale * 1.5;
                this.mesh.position.set(start.x * TILE_SIZE, yOffset, start.z * TILE_SIZE);
                
                this.hp = hp;
                this.maxHp = hp;
                this.speed = speed;
                this.pathIndex = 0;
                this.dead = false;
                this.animTime = Math.random() * 100;
                this.reward = this.reward || 15;
                
                if (!isBalloon || balloonSize > 1) {
                    const barGeo = new THREE.PlaneGeometry(2, 0.2);
                    const barMat = new THREE.MeshBasicMaterial({color: 0x00ff00});
                    this.hpBar = new THREE.Mesh(barGeo, barMat);
                    this.hpBar.position.y = charScale * 2.5;
                    this.mesh.add(this.hpBar);
                }
                scene.add(this.mesh);
            }

            update(dt) {
                if (this.dead) return;
                dt *= gameSpeed;
                this.animTime += dt;
                
                if (this.canPhase) {
                    this.phaseTimer -= dt;
                    if (this.phaseTimer <= 0) {
                        this.isPhasing = !this.isPhasing;
                        this.phaseTimer = this.isPhasing ? 2 : 3;
                        
                        if (this.isPhasing) {
                            sfx.playPhase();
                            this.mesh.traverse(child => {
                                if (child.material) {
                                    child.material.transparent = true;
                                    child.material.opacity = 0.3;
                                }
                            });
                        } else {
                            this.mesh.traverse(child => {
                                if (child.material) child.material.opacity = 1.0;
                            });
                        }
                    }
                }
                
                if (this.canHeal) {
                    this.healCooldown -= dt;
                    if (this.healCooldown <= 0) {
                        this.healCooldown = 3;
                        entities.enemies.forEach(e => {
                            if (e !== this && !e.dead && this.mesh.position.distanceTo(e.mesh.position) < 10) {
                                e.hp = Math.min(e.maxHp, e.hp + e.maxHp * 0.2);
                                if (e.hpBar) {
                                    const pct = e.hp / e.maxHp;
                                    e.hpBar.scale.x = pct;
                                    e.hpBar.material.color.setHSL(pct * 0.3, 1, 0.5);
                                }
                                sfx.playHeal();
                                spawnParticles(e.mesh.position, 0x00ff88, 5);
                            }
                        });
                    }
                }
                
                const path = LEVELS[gameState.levelIndex].path;
                if (this.pathIndex >= path.length - 1) {
                    this.hitBase();
                    return;
                }

                const targetGrid = path[this.pathIndex + 1];
                const targetPos = new THREE.Vector3(targetGrid.x * TILE_SIZE, this.mesh.position.y, targetGrid.z * TILE_SIZE);
                const dir = new THREE.Vector3().subVectors(targetPos, this.mesh.position);
                const dist = dir.length();

                if (dist < 0.2) {
                    this.pathIndex++;
                } else {
                    dir.normalize();
                    const angle = Math.atan2(dir.x, dir.z);
                    this.mesh.rotation.y = angle;
                    this.mesh.position.add(dir.multiplyScalar(this.speed * dt));
                    
                    if (this.mesh.userData.legL && !this.isBalloon) {
                        const parts = this.mesh.userData;
                        parts.legL.rotation.x = Math.sin(this.animTime * 12) * 0.7;
                        parts.legR.rotation.x = Math.cos(this.animTime * 12) * 0.7;
                        parts.armL.rotation.x = Math.cos(this.animTime * 12) * 0.5;
                        parts.armR.rotation.x = Math.sin(this.animTime * 12) * 0.5;
                        parts.torso.position.y = Math.sin(this.animTime * 24) * 0.05 * parts.scale;
                    } else if (this.isBalloon) {
                        this.mesh.rotation.y += dt * 2;
                    }
                }
            }

            takeDamage(dmg, towerType) {
                if (this.isPhasing) return;
                
                if (this.isNatron && towerType !== undefined) {
                    if (!this.damageByType[towerType]) this.damageByType[towerType] = 0;
                    const maxDamageFromType = this.maxHp * 0.35;
                    const remainingAllowedDamage = maxDamageFromType - this.damageByType[towerType];
                    const actualDamage = Math.min(dmg, remainingAllowedDamage);
                    this.damageByType[towerType] += actualDamage;
                    this.hp -= actualDamage;
                } else {
                    this.hp -= dmg;
                }
                
                if (this.hpBar) {
                    const pct = Math.max(0, this.hp / this.maxHp);
                    this.hpBar.scale.x = pct;
                    this.hpBar.material.color.setHSL(pct * 0.3, 1, 0.5);
                }
                
                if (this.canSplit && this.splits < this.maxSplits && this.hp > 0 && this.hp < this.maxHp * 0.5) {
                    this.splits++;
                    setTimeout(() => {
                        const newEnemy = new Enemy(this.type);
                        newEnemy.hp = this.maxHp * 0.3;
                        newEnemy.maxHp = this.maxHp * 0.3;
                        newEnemy.mesh.position.copy(this.mesh.position);
                        newEnemy.mesh.position.x += (Math.random() - 0.5) * 3;
                        newEnemy.mesh.position.z += (Math.random() - 0.5) * 3;
                        newEnemy.pathIndex = this.pathIndex;
                        newEnemy.canSplit = false;
                        entities.enemies.push(newEnemy);
                        sfx.playResonantRing();
                    }, 100);
                }

                if (this.hp <= 0 && !this.dead) {
                    this.dead = true;
                    
                    if (this.isBalloon && this.balloonSize > 1) {
                        sfx.playResonantRing();
                        setTimeout(() => {
                            for (let i = 0; i < 2; i++) {
                                const newBalloon = new Enemy('NORMAL', true, this.balloonSize - 1);
                                newBalloon.mesh.position.copy(this.mesh.position);
                                newBalloon.mesh.position.x += (i - 0.5) * 2;
                                newBalloon.pathIndex = this.pathIndex;
                                entities.enemies.push(newBalloon);
                            }
                        }, 100);
                    } else {
                        sfx.playResonantRing();
                    }
                    
                    const moneyGain = this.isBalloon ? 5 * this.balloonSize : (this.type === 'BOSS' ? 100 : this.reward);
                    gameState.money += moneyGain;
                    updateUI();
                    
                    const particleColor = this.mesh.material ? this.mesh.material.color.getHex() : 0xff0055;
                    spawnParticles(this.mesh.position, particleColor, this.isBalloon ? 5 : 10);
                    shake.amount = this.isBalloon ? 0.1 : 0.3;
                    scene.remove(this.mesh);
                }
            }

            hitBase() {
                this.dead = true;
                scene.remove(this.mesh);
                if (neuroCore && !neuroCore.destroyed) neuroCore.takeDamage();
                gameState.lives--;
                updateUI();
            }
        }

        class Tower {
            constructor(x, z, typeIndex) {
                this.typeIndex = typeIndex;
                this.level = 0;
                const typeData = TOWER_TYPES[typeIndex];
                this.typeData = typeData;
                this.data = typeData.upgrades[0];
                this.isCollapsed = false;
                
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, 1, z);
                this.mesh.userData.tower = this;

                this.createGeometry();
                this.mesh.scale.set(0.1,0.1,0.1);
                this.cooldown = 0;
                this.animTime = 0;
            }

            createGeometry() {
                while(this.mesh.children.length > 0) {
                    this.mesh.remove(this.mesh.children[0]);
                }

                const size = 1 + this.level * 0.15;
                const coreGeo = new THREE.IcosahedronGeometry(0.8 * size, 0);
                const coreMat = new THREE.MeshBasicMaterial({ color: this.data.color, wireframe: true });
                this.hackerCore = new THREE.Mesh(coreGeo, coreMat);
                this.hackerCore.position.y = 1;
                this.mesh.add(this.hackerCore);

                const cloudCount = 20 + this.level * 10;
                const cloudGeo = new THREE.BufferGeometry();
                const cloudPos = new Float32Array(cloudCount * 3);
                for(let i=0; i<cloudCount*3; i++) {
                    cloudPos[i] = (Math.random()-0.5) * 3 * size;
                }
                cloudGeo.setAttribute('position', new THREE.BufferAttribute(cloudPos, 3));
                const cloudMat = new THREE.PointsMaterial({ 
                    color: this.data.color, size: 0.3, transparent: true, opacity: 0.7
                });
                this.dataCloud = new THREE.Points(cloudGeo, cloudMat);
                this.dataCloud.position.y = 1;
                this.mesh.add(this.dataCloud);

                const baseGeo = new THREE.CylinderGeometry(1.5 * size, 2 * size, 0.5, 6);
                const baseMat = new THREE.MeshStandardMaterial({ 
                    color: 0x222222, emissive: this.data.color, emissiveIntensity: 0.3
                });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 0.25;
                this.mesh.add(base);

                this.light = new THREE.PointLight(this.data.color, 1 + this.level * 0.5, 8);
                this.light.position.y = 1;
                this.mesh.add(this.light);

                scene.add(this.mesh);
            }

            upgrade() {
                if (this.level < this.typeData.upgrades.length - 1) {
                    this.level++;
                    this.data = this.typeData.upgrades[this.level];
                    this.createGeometry();
                }
            }

            getTotalCost() {
                let total = this.typeData.baseCost;
                for (let i = 1; i <= this.level; i++) {
                    total += this.typeData.upgrades[i].cost;
                }
                return total;
            }

            update(dt) {
                this.mesh.scale.lerp(new THREE.Vector3(1,1,1), dt * 10);
                this.cooldown -= dt;
                this.animTime += dt;

                if (this.hackerCore) {
                    this.hackerCore.rotation.y = this.animTime * 2;
                    this.hackerCore.rotation.z = this.animTime;
                    const pulse = 1 + Math.sin(this.animTime * 10) * 0.1;
                    this.hackerCore.scale.setScalar(pulse);
                }
                
                if (this.dataCloud) {
                    this.dataCloud.rotation.y = -this.animTime * 0.5;
                }

                if (this.isCollapsed) return;

                let target = null;
                let minDist = this.data.range;

                for (const e of entities.enemies) {
                    if (e.dead || e.isPhasing) continue;
                    const d = this.mesh.position.distanceTo(e.mesh.position);
                    if (d < minDist) {
                        minDist = d;
                        target = e;
                    }
                }

                if (target) {
                    if (this.cooldown <= 0) {
                        this.shoot(target);
                        this.cooldown = this.data.rate;
                    }
                }
            }

            shoot(target) {
                if(this.typeIndex === 0) sfx.playSonicWave();
                else if(this.typeIndex === 1) sfx.playTremoloWave();
                else if(this.typeIndex === 2) sfx.playUnderwaterEcho();

                if (this.light) {
                    this.light.intensity = 3;
                    setTimeout(() => { this.light.intensity = 1 + this.level * 0.5; }, 100);
                }

                entities.projectiles.push(new Projectile(
                    this.mesh.position.clone().add(new THREE.Vector3(0, 1, 0)),
                    target,
                    this.data,
                    this.typeData.projectileSpeed,
                    this.typeIndex
                ));
            }
        }

        class Projectile {
            constructor(pos, target, data, speed, towerType) {
                this.pos = pos;
                this.target = target;
                this.data = data;
                this.speed = speed;
                this.towerType = towerType;
                
                const tex = Math.random() > 0.5 ? texZero : texOne;
                const mat = new THREE.SpriteMaterial({ 
                    map: tex, color: data.color, transparent: true
                });
                this.mesh = new THREE.Sprite(mat);
                this.mesh.position.copy(pos);
                this.mesh.scale.set(1, 1, 1);
                
                this.active = true;
                scene.add(this.mesh);

                this.light = new THREE.PointLight(data.color, 0.5, 3);
                this.mesh.add(this.light);
            }

            update(dt) {
                if (!this.active) return;
                if ((this.target.dead || this.target.isPhasing) && !this.data.aoe) {
                    this.active = false; 
                    scene.remove(this.mesh); 
                    return;
                }

                const targetPos = this.target.mesh.position.clone();
                targetPos.y += 1;
                const dir = new THREE.Vector3().subVectors(targetPos, this.mesh.position).normalize();
                this.mesh.position.add(dir.multiplyScalar(this.speed * dt));

                if (this.mesh.position.distanceTo(targetPos) < 1.0) {
                    this.hit();
                }
            }

            hit() {
                this.active = false;
                scene.remove(this.mesh);
                
                if (this.data.aoe) {
                    spawnParticles(this.mesh.position, this.data.color, 20);
                    sfx.playResonantRing();
                    entities.enemies.forEach(e => {
                        if (e.mesh.position.distanceTo(this.mesh.position) < this.data.aoe) {
                            e.takeDamage(this.data.damage, this.towerType);
                        }
                    });
                } else {
                    if (!this.target.dead && !this.target.isPhasing) {
                        this.target.takeDamage(this.data.damage, this.towerType);
                    }
                }
            }
        }

        function spawnParticles(pos, color, count) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.position.x += (Math.random()-0.5);
                mesh.position.z += (Math.random()-0.5);
                
                const vel = new THREE.Vector3(
                    (Math.random()-0.5) * 10,
                    (Math.random()) * 10,
                    (Math.random()-0.5) * 10
                );
                
                entities.particles.push({ mesh, vel, life: 1.0 });
                scene.add(mesh);
            }
        }

        function startWave() {
            if (gameState.isGameOver) return;
            
            if (gameState.wave > 1) {
                collapseTileWithTower();
            }
            
            const msg = document.getElementById('msg-area');
            msg.innerText = "WAVE " + gameState.wave;
            msg.style.opacity = 1;
            setTimeout(() => msg.style.opacity = 0, 2000);

            const level = LEVELS[gameState.levelIndex];
            const cfg = level.isSandbox ? gameState.sandboxConfig : null;

            let baseCount = cfg ? cfg.enemyCount : 5;
            let diffScale = cfg ? cfg.difficultyScale : 1.0;
            let total = Math.floor(baseCount + (gameState.wave - 1) * 1.5 * diffScale);
            
            if (cfg && cfg.maxWaves && gameState.wave > cfg.maxWaves) {
                victoryScreen();
                return;
            }
            
            const intervalTime = Math.max(200, 1500 - gameState.wave * 50);
            let count = 0;

            const spawner = setInterval(() => {
                if (gameState.isGameOver || isPaused) { 
                    if (gameState.isGameOver) clearInterval(spawner);
                    return;
                }
                
                let type = 'NORMAL';
                let isBalloon = level.isBalloonLevel || false;
                
                if (!isBalloon) {
                    if (cfg) {
                        const r = Math.random();
                        const totalMix = cfg.enemyMix.normal + cfg.enemyMix.speed + cfg.enemyMix.tank;
                        const normalThreshold = cfg.enemyMix.normal / totalMix;
                        const speedThreshold = normalThreshold + (cfg.enemyMix.speed / totalMix);
                        
                        if (r < normalThreshold) type = 'NORMAL';
                        else if (r < speedThreshold) type = 'SPEED';
                        else type = 'TANK';
                    } else {
                        const r = Math.random();
                        if (gameState.wave > 3 && r > 0.85) type = 'SPEED';
                        else if (gameState.wave > 5 && r > 0.9) type = 'TANK';
                        
                        if (gameState.wave >= 7) {
                            if (r < 0.05) type = 'ASSASSIN';
                            else if (r > 0.93 && r < 0.96) type = 'GHOST';
                            else if (r > 0.96 && r < 0.98) type = 'SPLITTER';
                        }
                        if (gameState.wave >= 10) {
                            if (r > 0.88 && r < 0.91) type = 'JUGGERNAUT';
                            else if (r > 0.98 && r < 0.99) type = 'HEALER';
                            else if (r > 0.99) type = 'NATRON';
                        }
                    }
                    
                    const bossInterval = cfg ? cfg.bossInterval : 5;
                    if (gameState.wave % bossInterval === 0 && count === total - 1) type = 'BOSS';
                }

                if (isBalloon) {
                    const size = Math.min(4, Math.floor(1 + gameState.wave * 0.3));
                    entities.enemies.push(new Enemy(type, true, size));
                } else {
                    entities.enemies.push(new Enemy(type));
                }
                
                count++;

                if (count >= total) {
                    clearInterval(spawner);
                    checkWaveEnd();
                }
            }, intervalTime);
        }

        function checkWaveEnd() {
            const check = setInterval(() => {
                if (gameState.isGameOver) { clearInterval(check); return; }
                if (isPaused) return;
                
                if (entities.enemies.length === 0) {
                    clearInterval(check);
                    gameState.wave++;
                    updateUI();
                    setTimeout(startWave, 3000);
                }
            }, 1000);
        }

        function victoryScreen() {
            gameState.isGameOver = true;
            saveHighscore();
            document.getElementById('victory-msg').innerText = `Completed ${gameState.wave - 1} Waves!`;
            document.getElementById('victory-screen').style.display = 'flex';
        }

        function onPointerDown(e) {
            sfx.init();
            if (gameState.isGameOver || isPaused) return;
            if (e.target.tagName !== 'CANVAS') return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const towerMeshes = entities.towers.map(t => t.mesh);
            const towerIntersects = raycaster.intersectObjects(towerMeshes, true);
            
            if (towerIntersects.length > 0) {
                let tower = null;
                let obj
 = towerIntersects[0].object;
                while (obj && !tower) {
                    if (obj.userData.tower) tower = obj.userData.tower;
                    obj = obj.parent;
                }
                
                if (tower) {
                    if (deleteMode) {
                        selectedTower = tower;
                        sellTower();
                    } else {
                        showTowerInfo(tower);
                    }
                    return;
                }
            }

            const intersects = raycaster.intersectObjects(entities.tiles);
            if (intersects.length > 0) {
                hideTowerInfo();
                
                const obj = intersects[0].object;
                
                if (obj.userData.collapsed) {
                    showTileInfo(obj);
                    return;
                }
                
                if (deleteMode) return;
                
                const typeData = TOWER_TYPES[gameState.selectedTowerType];
                const cost = typeData.baseCost;

                if (!obj.userData.isPath && !obj.userData.hasTower && gameState.money >= cost) {
                    gameState.money -= cost;
                    obj.userData.hasTower = true;
                    obj.material.color.setHex(0x111111);
                    
                    entities.towers.push(new Tower(obj.position.x, obj.position.z, gameState.selectedTowerType));
                    sfx.playBuild();
                    updateUI();
                } else if (gameState.money < cost) {
                    sfx.playError();
                }
            } else {
                hideTowerInfo();
            }
        }

        function updateUI() {
            document.getElementById('money-val').innerText = gameState.money;
            document.getElementById('lives-val').innerText = Math.max(0, gameState.lives * 5) + "%";
            document.getElementById('wave-val').innerText = gameState.wave;
        }

        function endGame() {
            gameState.isGameOver = true;
            saveHighscore();
            document.getElementById('final-score').innerText = "WAVES SURVIVED: " + (gameState.wave - 1);
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.012);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            controls.minDistance = 10;
            controls.maxDistance = 80;

            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
            fillLight.position.set(-20, 30, -20);
            scene.add(fillLight);

            const bgGeo = new THREE.PlaneGeometry(200, 200);
            const bgMesh = new THREE.Mesh(bgGeo, bgMaterial);
            bgMesh.rotation.x = -Math.PI / 2;
            bgMesh.position.y = -2;
            scene.add(bgMesh);

            matrixSkyDome = createMatrixSkyDome();
            scene.add(matrixSkyDome);

            // === SCHRITT 2: Nebel Wolken und Glitzer Partikel erstellen ===
            fogCloudGroup = createFogClouds();
            scene.add(fogCloudGroup);

            glitterGroup = createGlitterParticles();
            scene.add(glitterGroup);
            // === END SCHRITT 2 ===

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onResize);
            window.addEventListener('pointerdown', onPointerDown);
            loadHighscores();
            animate();
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = isPaused ? 0 : clock.getDelta();
            const time = clock.getElapsedTime();

            bgUniforms.uTime.value = time;
            if (matrixSkyDome) {
                matrixSkyDome.userData.uniforms.uTime.value = time;
            }

            // === SCHRITT 3: Update Nebel und Glitzer (nur wenn nicht pausiert) ===
            if (!isPaused && !gameState.isGameOver) {
                updateFogClouds(dt, time);
                updateGlitterParticles(dt, time);
            }
            // === END SCHRITT 3 ===

            if (shake.amount > 0) {
                camera.position.x += (Math.random() - 0.5) * shake.amount;
                camera.position.y += (Math.random() - 0.5) * shake.amount;
                camera.position.z += (Math.random() - 0.5) * shake.amount;
                shake.amount = Math.max(0, shake.amount - (isPaused ? 0 : dt * 2));
            }
            controls.update();

            if (portalGateway && !gameState.isGameOver) {
                portalGateway.update(dt);
            }

            if (neuroCore && !gameState.isGameOver) {
                neuroCore.update(dt);
            }

            if (!gameState.isGameOver && !isPaused) {
                entities.enemies.forEach((e, i) => {
                    e.update(dt);
                    if (e.dead) entities.enemies.splice(i, 1);
                });

                entities.towers.forEach(t => t.update(dt));
                entities.projectiles.forEach((p, i) => {
                    p.update(dt);
                    if (!p.active) entities.projectiles.splice(i, 1);
                });
            }

            entities.particles.forEach((p, i) => {
                p.life -= (isPaused ? 0 : dt);
                p.vel.y -= (isPaused ? 0 : 20 * dt);
                p.mesh.position.add(p.vel.clone().multiplyScalar(isPaused ? 0 : dt));
                p.mesh.rotation.x += (isPaused ? 0 : dt * 5);
                p.mesh.scale.multiplyScalar(isPaused ? 1 : 0.95);
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    entities.particles.splice(i, 1);
                }
            });

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
